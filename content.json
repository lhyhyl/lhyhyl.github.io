{"meta":{"title":"北街学长的博客","subtitle":"脚踏实地,抓住机会","description":"电子科技大学22级研究生","author":"北街学长","url":"http://lhyhyl.github.io","root":"/"},"pages":[{"title":"所有分类","date":"un33fin33","updated":"un33fin33","comments":true,"path":"categories/index.html","permalink":"http://lhyhyl.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"un33fin33","updated":"un33fin33","comments":true,"path":"about/index.html","permalink":"http://lhyhyl.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"un33fin33","updated":"un33fin33","comments":true,"path":"tags/index.html","permalink":"http://lhyhyl.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"un33fin33","updated":"un33fin33","comments":true,"path":"friends/index.html","permalink":"http://lhyhyl.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"一文读懂红黑树","slug":"经典算法解析/带你彻底理解红黑树","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/经典算法解析/带你彻底理解红黑树/","permalink":"http://lhyhyl.github.io/2023/12/23/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"","text":"写在前面 当在 10 亿数据进行不到 30 次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ —— 学红黑树有感。 终于，在学习了几天的红黑树相关的知识后，我想把我所学所想和所感分享给大家。红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等一连串的问题在学习前困扰着我。如果你在学习过程中也会存在我的疑问，那么本文对你会有帮助，本文帮助你全面、彻底地理解红黑树！ 本文将通过图文的方式讲解红黑树的知识点，并且不会涉及到任何代码，相信我，在懂得红黑树实现原理前，看代码会一头雾水的，当原理懂了，代码也就按部就班写而已，没任何难度。 阅读本文你需具备知识点： 二叉查找树 完美平衡二叉树 2-3-4树 事不宜迟，让我们进入正题吧。 前置知识 二叉查找树 二叉查找树也称为二叉搜索树,满足二叉树的一般性质,但在此之上还具有以下性质: 若任意节点的左子树不空,则左子树上所有节点的值均小于它的根节点的值; 若任意节点的右子树不空,则右子树上的所有节点的值均大于它的根结点的值; 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点； 二叉查找树的查找算法 ​ 其过程可描述为: 若T为空树,则查找失败,否则 若x等于T的根结点的数据域之值,则查找成功,否则: 若x小于T的根结点的数据域之值,则搜索左子树,否则: 查找右子树。 递归代码： 12345678910111213BiTree *SearchBST(BiTree *T, KeyType key) &#123; // 在根指针T所指二叉查找树中递归地查找其关键字等于key的数据元素，若查找成功， // 则返回当前结点，否则， // 根据当前结点的值与关键字key的关系，进行左递归或右递归 if (!T) &#123; // 查找不成功 return NULL; &#125; else if (key == T-&gt;data) &#123; // 查找成功 return T; &#125; else if (key &lt; T-&gt;data) // 在左子树中继续查找 return SearchBST(T-&gt;lchild, key); else // 在右子树中继续查找 return SearchBST(T-&gt;rchild, key);&#125; ​ 非递归代码： 12345678910111213141516BiTree *SearchBST(BiTree *T, KeyType key) &#123; // 在根指针T所指二叉查找树中递归地查找其关键字等于key的数据元素，若查找成功， // 则返回当前结点，否则， // 根据当前结点的值与关键字key的关系，进行左递归或右递归 while(T)&#123; if(T-&gt;data == key)&#123;//查找成功 return T; &#125;else if(key &lt; T-&gt;data)&#123;//在左子树中继续查找 T=T-&gt;lchild; &#125;else T=T-&gt;rchild;//在右子树中继续查找 &#125; return NULL;//查找失败 &#125; 二叉查找树的删除算法 在二叉查找树删去一个结点，分三种情况讨论： 若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。 若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉查找树的特性。 若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令p的左子树为f的左/右（依p是f的左子树还是右子树而定）子树，s为p左子树的最右下的结点，而p的右子树为s的右子树；其二是令p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。我们采取第二种做法,因为红黑树也是这样做的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//寻找结点BiTree* getNode(const char *key) &#123;//通过值寻找结点 BiTree* p = root;//工作指针 while (p) &#123; if (atoi(p-&gt;key) == atoi(key)) &#123; return p; &#125; else if (atoi(p-&gt;key) &lt; atoi(key)) p = p-&gt;right; else p = p-&gt;left; &#125; return NULL;&#125;//寻找前驱结点BiTree* predecessor(BiTree* e) &#123; if (!e)return NULL; //寻找当前结点的前驱有两种情况: BiTree* p = NULL;//工作指针 //1.当前结点有左孩子,那么前驱是左子树的最右结点 if (e-&gt;left) &#123; p = e-&gt;left; while (p-&gt;right) &#123; p = p-&gt;right; &#125; return p; &#125; //2.当前结点没有左孩子,如果当前结点为右孩子,那么前驱是就是它的父亲结点 if (e == e-&gt;parent-&gt;right) return e-&gt;parent; else &#123; //3.无右孩子,如果当前结点为左孩子,那么其后继结点为向上身为第一颗右子树结点的父亲结点 p = e-&gt;parent; while (p &amp;&amp; p != p-&gt;parent-&gt;right) &#123; p = p-&gt;parent; &#125; return p-&gt;parent; &#125; return NULL;&#125;//寻找后继结点BiTree* successor(BiTree* e) &#123; if (!e)return NULL; //此时有三种情况 BiTree* p = NULL;//工作指针 //1.有右孩子,那么其后继结点就是其右孩子的最左结点 if (e-&gt;right) &#123; p = e-&gt;right; while (p-&gt;left) &#123; p = p-&gt;left; &#125; return p; &#125; else &#123; //2.无右孩子,如果当前结点为左孩子,那么其后继结点为其父节点 if (e == e-&gt;parent-&gt;left) return e-&gt;parent; else &#123; //3.无右孩子,如果当前结点为右孩子,那么其后继结点为向上身为第一颗左子树结点的父亲结点 p = e-&gt;parent; while (p &amp;&amp; p != p-&gt;parent-&gt;left) &#123; p = p-&gt;parent; &#125; return p-&gt;parent; &#125; &#125; return NULL;&#125; 正文 红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。现在在脑海想下怎么实现？是不是太多情景需要考虑了？啧啧，先别急，通过本文的学习后，你会觉得，其实也不过如此而已。好吧，我们先来看下红黑树的定义和一些基本性质。 红黑树定义和性质 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： 性质 1：每个节点要么是黑色，要么是红色。 性质 2：根节点是黑色。 性质 3：每个叶子节点（NIL）是黑色。 性质 4：每个红色结点的两个子结点一定都是黑色。 性质 5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 从性质 5 又可以推出： 性质 5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点 图 1 就是一颗简单的红黑树。其中 Nil 为叶子结点 (2020/01/16 补充：图 1 中的红色结点 H 和 M 同样存在叶子子结点，后文的图类似，不再阐明。感谢评论区的同学提醒，带来误解抱歉。)，并且它是黑色的。(值得提醒注意的是，在 Java 中，叶子结点是为 null 的结点。) 图 1 一颗简单的红黑树 红黑树并不是一个_完美_平衡二叉查找树，从图 1 可以看到，根结点 P 的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点 (性质 5)。所以我们叫红黑树这种平衡为黑色完美平衡。 介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如图 2 所示。 图 2 结点叫法约定 我们把正在处理 (遍历) 的结点叫做当前结点，如图 2 中的 D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。 前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。 左旋：以某个结点作为支点 (旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图 3。 右旋：以某个结点作为支点 (旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图 4。 变色：结点的颜色由红变黑或由黑变红。 图 3 左旋 图 4 右旋 上面所说的旋转结点也即旋转的支点，图 4 和图 5 中的 P 结点。 我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了。 右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了。 所以旋转操作是局部的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树 “借” 一些结点；当一边子树的结点多了，那么向另外一边子树 “租” 一些结点。 但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住红黑树总是通过旋转和变色达到自平衡。 balabala 了这么多，相信你对红黑树有一定印象了，那么现在来考考你： 思考题 1：黑结点可以同时包含一个红子结点和一个黑子结点吗？ (答案见文末) 接下来先讲解红黑树的查找热热身。 红黑树查找 因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异： 从根结点开始查找，把根结点设置为当前结点； 若当前结点为空，返回 null； 若当前结点不为空，用当前结点的 key 跟查找 key 作比较； 若当前结点 key 等于查找 key，那么该 key 就是查找目标，返回当前结点； 若当前结点 key 大于查找 key，把当前结点的左子结点设置为当前结点，重复步骤 2； 若当前结点 key 小于查找 key，把当前结点的右子结点设置为当前结点，重复步骤 2； 如图 5 所示。 图 5 二叉树查找流程图 非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为 O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～ 红黑树插入 插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大： 从根结点开始查找； 若根结点为空，那么插入结点作为根结点，结束。 若根结点不为空，那么把根结点作为当前结点； 若当前结点为 null，返回当前结点的父结点，结束。 若当前结点 key 等于查找 key，那么该 key 所在结点就是插入结点，更新结点的值，结束。 若当前结点 key 大于查找 key，把当前结点的左子结点设置为当前结点，重复步骤 4； 若当前结点 key 小于查找 key，把当前结点的右子结点设置为当前结点，重复步骤 4； 如图 6 所示。 图 6 红黑树插入位置查找 ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是红色。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡。 所有插入情景如图 7 所示。 图 7 红黑树插入情景 嗯，插入情景很多呢，8 种插入情景！但情景 1、2 和 3 的处理很简单，而情景 4.2 和情景 4.3 只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。 另外，根据二叉树的性质，除了情景 2，所有插入操作都是在叶子结点进行的。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。 在开始每个情景的讲解前，我们还是先来约定下，如图 8 所示。 图 8 插入操作结点的叫法约定 图 8 的字母并不代表结点 Key 的大小。I 表示插入结点，P 表示插入结点的父结点，S 表示插入结点的叔叔结点，PP 表示插入结点的祖父结点。 好了，下面让我们一个一个来分析每个插入的情景以其处理。 插入情景 1：红黑树为空树 最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质 2：根节点是黑色。还需要把插入结点设为黑色。 处理：把插入结点作为根结点，并把结点设置为黑色。 插入情景 2：插入结点的 Key 已存在 插入结点的 Key 已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。 处理： 把 I 设为当前结点的颜色 更新当前结点的值为插入结点的值 插入情景 3：插入结点的父结点为黑结点 由于插入的结点是红色的，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。 处理：直接插入。 插入情景 4：插入结点的父结点为红结点 再次回想下红黑树的性质 2：根结点是黑色。如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。 情景 4 又分为很多子情景，下面将进入重点部分，各位看官请留神了。 插入情景 4.1：叔叔结点存在并且为红结点 从红黑树性质 4 可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图 9 和图 10 所示。 处理： 将 P 和 S 设置为黑色 将 PP 设置为红色 把 PP 设置为当前插入结点 图 9 插入情景 4.1_1 图 10 插入情景 4.1_2 可以看到，我们把 PP 结点设为红色了，如果 PP 的父结点是黑色，那么无需再做任何处理；但如果 PP 的父结点是红色，根据性质 4，此时红黑树已不平衡了，所以还需要把 PP 当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。 试想下 PP 刚好为根结点时，那么根据性质 2，我们必须把 PP 重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。这也是唯一一种会增加红黑树黑色结点层数的插入情景。 我们还可以总结出另外一个经验：红黑树的生长是自底向上的。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。 插入情景 4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点 单纯从插入前来看，也即不算情景 4.1 自底向上处理时的情况，叔叔结点非红即为叶子结点 (Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质 5。后续情景同样如此，不再多做说明了。 前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。 插入情景 4.2.1：插入结点是其父结点的左子结点****处理： 将 P 设为黑色 将 PP 设为红色 对 PP 进行右旋 图 11 插入情景 4.2.1 由图 11 可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。 咦，可以把 P 设为红色，I 和 PP 设为黑色吗？答案是可以！看过《算法：第 4 版》的同学可能知道，书中讲解的就是把 P 设为红色，I 和 PP 设为黑色。但把 P 设为红色，显然又会出现情景 4.1 的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～ 插入情景 4.2.2：插入结点是其父结点的右子结点 这种情景显然可以转换为情景 4.2.1，如图 12 所示，不做过多说明了。 处理： 对 P 进行左旋 把 P 设置为插入结点，得到情景 4.2.1 进行情景 4.2.1 的处理 图 12 插入情景 4.2.2 插入情景 4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点 该情景对应情景 4.2，只是方向反转，不做过多说明了，直接看图。 插入情景 4.3.1：插入结点是其父结点的右子结点****处理： 将 P 设为黑色 将 PP 设为红色 对 PP 进行左旋 图 13 插入情景 4.3.1 插入情景 4.3.2：插入结点是其父结点的左子结点****处理： 对 P 进行右旋 把 P 设置为插入结点，得到情景 4.3.1 进行情景 4.3.1 的处理 图 14 插入情景 4.3.2 好了，讲完插入的所有情景了。可能又同学会想：上面的情景举例的都是第一次插入而不包含自底向上处理的情况，那么上面所说的情景都适合自底向上的情况吗？答案是肯定的。理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的。好吧，在出个习题，请大家拿出笔和纸画下试试（请务必动手画下，加深印象）： 习题 1：请画出图 15 的插入自平衡处理过程。（答案见文末） 图 15 习题 1 红黑树删除 红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！ 红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。 二叉树删除结点找替代结点有 3 种情情景： 情景 1：若删除结点无子结点，直接删除 情景 2：若删除结点只有一个子结点，用子结点替换删除结点 情景 3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点 补充说明下，情景 3 的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：把二叉树所有结点投射在 X 轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点。如图 16 所示。 图 16 二叉树投射 x 轴后有序 接下来，讲一个重要的思路：**删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！**话很苍白，我们看图 17。在不看键值对的情况下，图 17 的红黑树最终结果是删除了 Q 所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！ 图 17 删除结点换位思路 基于此，上面所说的 3 种二叉树的删除情景可以相互转换并且最终都是转换为情景 1！ 情景 2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景 3，一直自顶向下转换，总是能转换为情景 1。（对于红黑树来说，根据性质 5.1，只存在一个子结点的结点肯定在树末了） 情景 3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景 2，否则转为为情景 1。 二叉树删除结点情景关系图如图 18 所示。 图 18 二叉树删除情景转换 综上所述，**删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。**有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。 同样的，我们也是先来总体看下删除操作的所有情景，如图 19 所示。 图 19 红黑树删除情景 哈哈，是的，即使简化了还是有 9 种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图 20 所示。 图 20 删除操作结点的叫法约定 图 20 的字母并不代表结点 Key 的大小。R 表示替代结点，P 表示替代结点的父结点，S 表示替代结点的兄弟结点，SL 表示兄弟结点的左子结点，SR 表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。 值得特别提醒的是，R 是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。 万事具备，我们进入最后的也是最难的讲解。 删除情景 1：替换结点是红色结点 我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。 处理：颜色变为删除结点的颜色 删除情景 2：替换结点是黑结点 当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。 删除情景 2.1：替换结点是其父结点的左子结点 删除情景 2.1.1：替换结点的兄弟结点是红结点 若兄弟结点是红结点，那么根据性质 4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图 21 处理，得到删除情景 2.1.2.3（后续讲解，这里先记住，此时 R 仍然是替代结点，它的新的兄弟结点 SL 和兄弟结点的子结点都是黑色）。 处理： 将 S 设为黑色 将 P 设为红色 对 P 进行左旋，得到情景 2.1.2.3 进行情景 2.1.2.3 的处理 图 21 删除情景 2.1.1 删除情景 2.1.2：替换结点的兄弟结点是黑结点 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点 Nil，Nil 结点为黑结点），此时又得考虑多种子情景。 删除情景 2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少 1 了，然而右子树又又红色结点，那么我们直接向右子树 “借” 个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图 22 所示。 处理： 将 S 的颜色设为 P 的颜色 将 P 设为黑色 将 SR 设为黑色 对 P 进行左旋 图 22 删除情景 2.1.2.1 平衡后的图怎么不满足红黑树的性质？前文提醒过，R 是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以 R 最终可以看作是删除的。另外图 2.1.2.1 是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL 肯定是红色或为 Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。 删除情景 2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景 2.1.2.1。图如 23 所示。 处理： 将 S 设为红色 将 SL 设为黑色 对 S 进行右旋，得到情景 2.1.2.1 进行情景 2.1.2.1 的处理 图 23 删除情景 2.1.2.2 删除情景 2.1.2.3：替换结点的兄弟结点的子结点都为黑结点 好了，此次兄弟子树都没红结点 “借” 了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在 P 所在的子树中保证平衡（R 即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。 处理： 将 S 设为红色 把 P 作为新的替换结点 重新进行删除结点情景处理 图 24 情景 2.1.2.3 删除情景 2.2：替换结点是其父结点的右子结点 好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景 2.1 后，肯定可以理解 2.2。 删除情景 2.2.1：替换结点的兄弟结点是红结点处理： 将 S 设为黑色 将 P 设为红色 对 P 进行右旋，得到情景 2.2.2.3 进行情景 2.2.2.3 的处理 图 25 删除情景 2.2.1 删除情景 2.2.2：替换结点的兄弟结点是黑结点删除情景 2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色处理： 将 S 的颜色设为 P 的颜色 将 P 设为黑色 将 SL 设为黑色 对 P 进行右旋 图 26 删除情景 2.2.2.1 删除情景 2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点****处理： 将 S 设为红色 将 SR 设为黑色 对 S 进行左旋，得到情景 2.2.2.1 进行情景 2.2.2.1 的处理 图 27 删除情景 2.2.2.2 删除情景 2.2.2.3：替换结点的兄弟结点的子结点都为黑结点****处理： 将 S 设为红色 把 P 作为新的替换结点 重新进行删除结点情景处理 图 28 删除情景 2.2.2.3 综上，红黑树删除后自平衡的处理可以总结为： 自己能搞定的自消化（情景 1） 自己不能搞定的叫兄弟帮忙（除了情景 1、情景 2.1.2.3 和情景 2.2.2.3） 兄弟都帮忙不了的，通过父母，找远方亲戚（情景 2.1.2.3 和情景 2.2.2.3） 哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～ 最后再做个习题加深理解（请不熟悉的同学务必动手画下）： *** 习题 2：请画出图 29 的删除自平衡处理过程。 习题 2 写在后面 耗时良久，终于写完了～自己加深了红黑树的理解的同时，也希望能帮助大家。如果你之前没学习过红黑树，看完这篇文章后可能还存在很多疑问，如果有疑问可以在评论区写出来，我会尽自己所能解答。另外给大家推荐一个支持红黑树在线生成的网站，来做各种情景梳理很有帮助：在线生成红黑树。（删除操作那个把替代结点看作删除结点思路就是我自己在用这个网站时自己顿悟的，我觉得这样讲解更容易理解。） 少了代码是不是觉得有点空虚？哈哈，后续我会写关于 Java 和 HashMap 和 TreeMap 的文章，里面都有红黑树相关的知识。相信看了这篇文章后，再去看 Java 和 HashMap 和 TreeMap 的源码绝对没难度！ 最后来看下思考题和习题的答案吧。 思考题和习题答案 思考题 1：黑结点可以同时包含一个红子结点和一个黑子结点吗？ 答：可以。如下图的 F 结点： 习题 1：请画出图 15 的插入自平衡处理过程。 答： 习题 2：请画出图 29 的删除自平衡处理过程。 答：","categories":[{"name":"算法经典","slug":"算法经典","permalink":"http://lhyhyl.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://lhyhyl.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"红黑树","slug":"红黑树","permalink":"http://lhyhyl.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}]},{"title":"读取文件创建图","slug":"数据结构百题狂练/图/从文件中读取数据以创建图","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/图/从文件中读取数据以创建图/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E5%9B%BE/%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%9B%BE/","excerpt":"","text":"背景：之前一直在控制台输入有关图所需的数据，可控制台极易输错，且要想达到好的测试效果，那么就需要大量数据，显然控制台输入太慢且费时，所以思考利用文件读取的方式。 文件格式如上图，第一行数据分别为边数与顶点数，第二行为顶点信息，之后便是边的信息。 我们的代码一定要根据文件结构来。 然后实现的代码如下，可能有很多不是特别优化的地方，但这是我目前能达到的最好效果了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void createGraphInFile(ALGraph *G) &#123;//从文件中读取我们的图的数据，包括边数，节点数，对应关系 FILE *fp;//创建文件指针 char ev[4] = &#123; 0 &#125;;//顶点，边个数信息 char arc[6] = &#123; 0 &#125;;//边信息 char *vertex;//顶点信息，名称 fp = fopen(&quot;graph.txt&quot;, &quot;r&quot;);//打开文件 if (fp == NULL) &#123; printf(&quot;该文件无法打开！&quot;); return; &#125; fgets(ev, 4, fp);//读取第一行 G-&gt;numE = atoi(&amp;ev[0]);//因为有空格所以跳着取值 G-&gt;numV = atoi(&amp;ev[2]);//用atoi()将字符型数据转化为整型 vertex = (char *)malloc(sizeof(char*)*G-&gt;numE);//这是用来存储顶点信息的数组（顶点的名字） for (int i = 0; i &lt;= G-&gt;numE; i++) &#123;//开始获取后面的信息 if (i == 0) &#123;//此时，根据我们文件的结构，第二行是顶点信息 fgets(ev, 4, fp);//获取回车符，上一次fgets后会停在回车符那儿 fgets(vertex,G-&gt;numV*2,fp);//这里获取顶点信息 int w = 0;//用一个计数器，保证adjlist依次存储顶点 for (int j = 0; j &lt; G-&gt;numV*2;j++) &#123;//因为有空格，所以让j&lt;G-&gt;numV*2 if (vertex[j]==32) &#123;//是空格，不进行操作 continue; &#125; else &#123;//开始赋值 G-&gt;adjlist[w].info = vertex[j]; G-&gt;adjlist[w].firstNode = NULL; w++; &#125; &#125; &#125; else &#123;//开始依次存储边信息 fgets(ev, 4, fp);//同样先吃掉换行符 fgets(arc, 6, fp);//读取该行的边信息 EdgeNode *e = (EdgeNode *)malloc(sizeof(EdgeNode *)); e-&gt;index = atoi(&amp;arc[2]) - 1;//数组下标要减一 e-&gt;weight = atoi(&amp;arc[4]); e-&gt;next = G-&gt;adjlist[atoi(&amp;arc[0])-1].firstNode;//采用头插法 G-&gt;adjlist[atoi(&amp;arc[0])-1].firstNode = e; //下面与上面相似，目的在于构建无向图 EdgeNode *otherE = (EdgeNode *)malloc(sizeof(EdgeNode *)); otherE-&gt;index = atoi(&amp;arc[0]) - 1;//数组下标要减一 otherE-&gt;weight = atoi(&amp;arc[4]); otherE-&gt;next = G-&gt;adjlist[atoi(&amp;arc[2]) - 1].firstNode; G-&gt;adjlist[atoi(&amp;arc[2]) - 1].firstNode = otherE; &#125; &#125; fclose(fp);&#125; 整体思想便是：一行一行的读取数据，在分别存储与相应的结构体中 可运行的整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/* 采用邻接表的方式存储图 分析： 采用邻接表相对于邻接矩阵来说更节省存储空间，这里我们需要两个数据结构： ①顶点表结构：包括顶点信息及指向第一个邻接点的头指针 ②边表结构：包括该邻接点域（在数组中的下标）、权值及下一个邻接点指针 ③一个数组，用于存储所有顶点，因为数组的随机存储特性，方便我们查找 ④图结构：包括顶点数组及顶点数、边数 具体创建流程： 首先我们需要输入图的顶点数和边数，将其存入图结构中，并由输入的顶点数依次输入顶点信息，并将第一个邻接点的头指针 置位NULL，这是建立顶点表的流程； 其次我们需要建立边表，根据输入的边个数，依次输入边（vi，vj）的顶点序号，再采取头插法进行插入，若是无向图则需要 重复反向依次设置，至此，图的邻接表结构建立完成。 */#define _CRT_SECURE_NO_WARNINGS#define MAXSIZE 100typedef struct EdgeNode &#123;//边表结点 int index;//邻接点在数组中的下标 int weight;//权值 EdgeNode *next;//下一个邻接点&#125;EdgeNode; typedef struct VertexNode &#123;//顶点表节点 char info;//顶点信息 EdgeNode *firstNode;//顶点的第一个邻接点指针&#125;VertexNode, Adjlist[MAXSIZE]; typedef struct &#123; Adjlist adjlist;//顶点数组 int numE, numV;//边数、顶点数&#125;ALGraph;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; void createGraph(ALGraph *G) &#123; int e, v, vi, vj, w; printf(&quot;请输入图的边数与结点数（以空格分开）：&quot;); scanf(&quot;\\n%d %d&quot;, &amp;e, &amp;v); G-&gt;numE = e; G-&gt;numV = v; printf(&quot;请依次输入顶点信息：\\n&quot;); for (int i = 0; i &lt; G-&gt;numV; i++) &#123; printf(&quot;请输入第%d个结点信息：&quot;, i + 1); scanf(&quot;\\n%c&quot;, &amp;G-&gt;adjlist[i].info); G-&gt;adjlist[i].firstNode = NULL; &#125; printf(&quot;请输入边表信息：\\n&quot;); for (int i = 0; i &lt; G-&gt;numE; i++) &#123; printf(&quot;请输入边（vi，vj）的顶点序号及其权值（以空格分开）：&quot;); scanf(&quot;%d %d %d&quot;, &amp;vi, &amp;vj, &amp;w); //若是无向图则需要两个顶点进行操作,采用头插法 EdgeNode *e = (EdgeNode *)malloc(sizeof(EdgeNode *)); e-&gt;index = vj - 1;//数组下标要减一 e-&gt;weight = w; e-&gt;next = G-&gt;adjlist[vi - 1].firstNode; G-&gt;adjlist[vi - 1].firstNode = e; /*EdgeNode *ed = (EdgeNode *)malloc(sizeof(EdgeNode *)); ed-&gt;index = vi - 1; ed-&gt;weight = w; ed-&gt;next = G-&gt;adjlist[vj - 1].firstNode; G-&gt;adjlist[vj - 1].firstNode = ed;*/ &#125; &#125;void createGraphInFile(ALGraph *G) &#123;//从文件中读取我们的图的数据，包括边数，节点数，对应关系 FILE *fp;//创建文件指针 char ev[4] = &#123; 0 &#125;;//顶点，边个数信息 char arc[6] = &#123; 0 &#125;;//边信息 char *vertex;//顶点信息，名称 fp = fopen(&quot;graph.txt&quot;, &quot;r&quot;);//打开文件 if (fp == NULL) &#123; printf(&quot;该文件无法打开！&quot;); return; &#125; fgets(ev, 4, fp);//读取第一行 G-&gt;numE = atoi(&amp;ev[0]);//因为有空格所以跳着取值 G-&gt;numV = atoi(&amp;ev[2]);//用atoi()将字符型数据转化为整型 vertex = (char *)malloc(sizeof(char*)*G-&gt;numE);//这是用来存储顶点信息的数组（顶点的名字） for (int i = 0; i &lt;= G-&gt;numE; i++) &#123;//开始获取后面的信息 if (i == 0) &#123;//此时，根据我们文件的结构，第二行是顶点信息 fgets(ev, 4, fp);//获取回车符，上一次fgets后会停在回车符那儿 fgets(vertex,G-&gt;numV*2,fp);//这里获取顶点信息 int w = 0;//用一个计数器，保证adjlist依次存储顶点 for (int j = 0; j &lt; G-&gt;numV*2;j++) &#123;//因为有空格，所以让j&lt;G-&gt;numV*2 if (vertex[j]==32) &#123;//是空格，不进行操作 continue; &#125; else &#123;//开始赋值 G-&gt;adjlist[w].info = vertex[j]; G-&gt;adjlist[w].firstNode = NULL; w++; &#125; &#125; &#125; else &#123;//开始依次存储边信息 fgets(ev, 4, fp);//同样先吃掉换行符 fgets(arc, 6, fp);//读取该行的边信息 EdgeNode *e = (EdgeNode *)malloc(sizeof(EdgeNode *)); e-&gt;index = atoi(&amp;arc[2]) - 1;//数组下标要减一 e-&gt;weight = atoi(&amp;arc[4]); e-&gt;next = G-&gt;adjlist[atoi(&amp;arc[0])-1].firstNode;//采用头插法 G-&gt;adjlist[atoi(&amp;arc[0])-1].firstNode = e; //下面与上面相似，目的在于构建无向图 EdgeNode *otherE = (EdgeNode *)malloc(sizeof(EdgeNode *)); otherE-&gt;index = atoi(&amp;arc[0]) - 1;//数组下标要减一 otherE-&gt;weight = atoi(&amp;arc[4]); otherE-&gt;next = G-&gt;adjlist[atoi(&amp;arc[2]) - 1].firstNode; G-&gt;adjlist[atoi(&amp;arc[2]) - 1].firstNode = otherE; &#125; &#125; fclose(fp);&#125;void dispGraph(ALGraph *G) &#123;//将图用邻接表的形式展示出来 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; int j = i; printf(&quot;%c--&gt;&quot;, G-&gt;adjlist[j].info); EdgeNode *p = G-&gt;adjlist[j].firstNode; while (p) &#123; printf(&quot;(%d)%c--&gt;&quot;, p-&gt;weight, G-&gt;adjlist[p-&gt;index].info); p = p-&gt;next; &#125; printf(&quot;^\\n&quot;); &#125; &#125;//int main() &#123;// ALGraph G;// createGraphInFile(&amp;G);// dispGraph(&amp;G);// return 0;//&#125; 希望能够帮到你~","categories":[{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/categories/%E5%9B%BE/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/tags/%E5%9B%BE/"}]},{"title":"数据结构全解析","slug":"数据结构讲义","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构讲义/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/","excerpt":"","text":"数据结构 第一章：数据结构的基本概念 定义 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。 数据：描述客观事物的数和字符的集合 数据项：具有独立含义的数据最小单元 数据对象：指性质相同的数据元素的集合，它是数据的一个子集 数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。 逻辑结构 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的，逻辑结构是为了方面人们进行理解。 数据的逻辑结构分为线性结构和非线性结构 集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合 线性结构 结构中的数据元素之间只存在一对一的关系。比如排队 树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱 图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如社交关系网 存储结构 存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示，也就是说我不仅要求计算机将每一个数据元素存储到空闲的内存中，还必须得将它们之间的关系表示出来。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。 顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。） 优点：存储效率高，随机存取 缺点：不便于数据修改，对元素的插入或删除操作可能需要移动一系列的元素 链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。在C语言里面用指针这个东西来指定，后续我们会讲到。 优点：便于数据修改 缺点：存储空间的利用率低，因为有一部分空间用来存储节点之间的逻辑关系 索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。每个数据元素都有一个关键字和对应的存储地址 优点：查找效率高 缺点：需要建立索引表，增加了空间开销 散列存储：根据元素的关键字通过哈希（散列）函数直接计算出一个值，并将这个值作为该元素的存储地址 优点：查找速度快 缺点：只负责对元素的存储任务，不负责存储元素之间的逻辑关系 算法 算法是对特定问题求解步骤的一种描述，它是指令的有限序列。大家都知道的一个故事：把大象装进冰箱（特定问题），第一步打开冰箱–第二步把大象塞进去–第三步关闭冰箱门（求解步骤）而整个指令是有限的，这其实就可以算是一个算法了 算法的五个特征 1，有穷性：有限步之后结束 2，确定性：不存在二义性，即没有歧义 3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。 4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。 5，输出：一至多个程序输出结果。 算法设计的目标 1, 正确性:要求算法能够正确地执行预先规定的功能和性能要求，这是最重要也是最基本的要求 2，可使用性：要求算法能够很方便的使用 3，可读性：易于理解 4，健壮性：要求算法具有很好的容错性，别那么脆弱 5，高效率和低存储量要求：简单来说，就是时间复杂度和空间复杂度要较低，其实现实中的很多问题都可以采用暴力算法解决，但是这样会很不友好，所以低时间、空间复杂度一直以来是科学家们所追求的 算法的复杂度 时间复杂度： • 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢； • 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级 • T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度 空间复杂度： • 它用来衡量算法随着问题规模增大，算法所需空间的快慢； • 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。 概要: 复杂度计算为重点（幕布讲解） 常用的时间复杂度大小关系：O(n!)&gt;O(2^n)&gt; O(n^3) &gt;O(n^2)&gt;O(nlog2n)&gt;O(n)&gt;O(logn)&gt;O(1) 复杂度如何计算 时间复杂度计算（单个循环体） 直接关注循环体的执行次数，设为k 时间复杂度计算（多个循环体） 两个运算规则：乘法规则，加法规则。 第二章：线性表 线性表的逻辑结构 定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表 特点： 有穷性：一个线性表中的元素个数是有限的 一致性：一个线性表中所有元素的性质相同。从实现的角度看，所有元素具有相同的数据类型 序列性：一个线性表中所有元素之间的相对位置是线性的，即存在唯一的开始元素和终端元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。 线性表的顺序存储结构 线性表的顺序存储又称为顺序表。 它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻 辑上相邻的两个元素在物理位置上也相邻。 建立顺序表的三个属性: 1.存储空间的起始位置（数组名data） 2.顺序表最大存储容量（MaxSize） 3.顺序表当前的长度（length） 其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配 总结： 1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。 2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定） 3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。 4.顺序表容易产生内存碎片 顺序表的操作 1.创建顺序表 算法思路： 1.根据顺序表长度分配空间 2.依次存入数据 代码： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100typedef struct &#123;//C语言方式 int data[MAXSIZE]; int length;&#125;SqList;struct SqList &#123;//c++方式，个人推荐这种方式，简单 int data[MAXSIZE]; int length;&#125;;SqList* createList(int length) &#123;//传入要创建的顺序表的长度 SqList* L = (SqList*)malloc(sizeof(SqList) * length);//分配存放线性表的空间 int data; for (int i = 0; i &lt; length; i++) &#123; printf(&quot;请输入第%d个元素&quot;, i); scanf(&quot;%d&quot;, L-&gt;data[i]); &#125; L-&gt;length = length; return L;&#125; 分析： 时间复杂度：很明显，这里用到了单层循环，时间复杂度为O(n)。 空间复杂度：这里给顺序表分配了空间，规模为n，所以空间复杂度为O(n)。 2.查找 算法思路： 从起始元素开始进行遍历 若当前元素即为要查找元素，查找结束，返回当前元素位置 若当前元素非要查找元素，继续向后查找，直至查找成功或到达表尾。 代码： 123456789int find(SqList* L,int n) &#123;//输入待查找顺序表和待查找元素值，返回待查找元素在顺序表中的下标，若未查找成功，返回-1 for (int i = 0; i &lt; L-&gt;length; i++) &#123; if (L-&gt;data[i] == n) return i; &#125; return -1;&#125; 3.删除 算法思路： 有两种删除，一种是直接传入要删除元素的下标，另一种是传入要删除元素的值。思路大同小异 1.传入下标或元素值从前往后依次进行比较 2.若当前元素为要删除元素（若是下标可直接定位到要删除元素位置） 3.取出当前元素 3.将被删元素后面的所有元素都依次向前移动一位 4.修改表长 代码 12345678910111213void del(SqList*L,int n) &#123;//传入顺序表以及待删除的元素值，假设待删除的元素唯一 for (int i = 0; i &lt; L-&gt;length; i++) &#123; if (L-&gt;data[i]==n) &#123;//找到 for (int j = i+1; j &lt; L-&gt;length; j++)//将后续元素往前移动 &#123; L-&gt;data[i] = L-&gt;data[i + 1]; &#125; break;//因为该值唯一，所以一旦找到并处理后就可以结束程序，也可以写return &#125; &#125; L-&gt;length--;//将顺序表的长度减一&#125; 分析 最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。 最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。 平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为 ∑i=1npi(n−i)=∑i=1n1n(n−i)=1nχn(n−1)2=n−12]\\sum_{i=1}^{n}p_i(n-i) = \\sum_{i=1}^{n}\\frac{1}{n}{(n-i)} = \\frac{1}{n}\\chi\\frac{n(n-1)}{2} = \\frac{n-1}{2}]∑i=1n​pi​(n−i)=∑i=1n​n1​(n−i)=n1​χ2n(n−1)​=2n−1​] 该算法的主要时间都是花费在元素的移动上，因此删除算法的平均时间复杂度为O(n) 4.插入 算法思路：我们要在第i (1≤i≤n+11\\leq i \\leq n+11≤i≤n+1 )个位置插入新元素e 从最后一个元素开始不断往后移动直至第i个元素 腾出的新位置插入新元素 代码： 12345678910bool insert(SqList*L,int newE,int i) &#123;//传入顺序表和待插入元素以及插入位置 if (i &lt;= 0 || i &gt;= L-&gt;length + 1) return false; for (int j = L-&gt;length - 1; j &gt;= i-1; j--) &#123; L-&gt;data[j] = L-&gt;data[j + 1]; &#125; L-&gt;data[i - 1] = newE; return true;&#125; 线性表的链式存储结构 链表概述: 顺序表必须占用一整块实现分配大小的存储空间,这样会降低存储空间的利用率,为此有了可以实现存储空间动态管理的链式存储结构-链表 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。所谓&quot;链&quot;,其实就是一个标志,用于揭示两个元素之间的逻辑关系. 在C/C++语言中,往往采用指针来表示&quot;链&quot;,称之为指针域,而其本身所携带的数据部分称之为数据域 相关术语: 头指针:在线性表的链式存储中,通常每个链表带有一个头结点,并通过头结点的指针位置标识该链表,我们将其称之为头指针 首指针:指向首节点(开始节点)的指针 尾指针:指向尾节点的指针 头结点:头结点指的是带头结点的链表中的第一个节点,结点内通常不存储信息,只会有一个指针域,指向首元结点 首元结点:第一个数据域有值的结点 为什么要设置头结点？ 1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。 图示: 顺序表与链表对比: 顺序表:需要连续的一段存储空间,插入删除元素通常需要平均移动半个表的元素,具有随机存取的特性 链表:不需要连续的存储空间,插入删除元素只需要更改相应结点的指针域即可,不具有随机存取的特性 单链表的操作 单链表的结构 单链表的结构如图所示 单链表的结构由两部分构成:data为数据域,用于存放节点本身的信息,next为指针域,里面存放着下一个结点的地址 单链表的结构体 1234struct SingleLink&#123; int data;//数据域 SingleLink *next;//指针域&#125; 单链表的基本操作 建立单链表 1.头插法建立单链表： 首先确定要创建的单链表元素个数,进行循环输入结点数值 每输入一个元素值都要创建一个单链表结点,将链表结点的数据域赋值为输入的值 将每一次创建的单链表结点s,利用头插法插入到链表头部 图示 代码 123456789101112131415161718//头插法创建单链表singleLink* createSingleLink() &#123; int n, data; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;, &amp;n); SingleLink* L = (SingleLink*)malloc(sizeof(SingleLink)); L-&gt;next = NULL; for (int i = 0; i &lt; n; i++) &#123; SingleLink* s = (singleLink*)malloc(sizeof(SingleLink)); printf(&quot;请输入第%d个节点的值(int)：&quot;, i + 1); scanf(&quot;%d&quot;, &amp;data); s-&gt;data = data; s-&gt;next = NULL; s-&gt;next = L-&gt;next; L-&gt;next = s; &#125; return L;&#125; 本算法的时间复杂度为O(n),n为单链表中数据结点的个数 特点:头插法在进行创建单链表时,最后形成的链表的数据元素的顺序与最初的输入顺序完全相反 2.尾插法建立单链表： 首先确定要创建的单链表元素个数,进行循环输入结点数值 每输入一个元素值都要创建一个单链表结点,将链表结点的数据域赋值为输入的值 将每一次创建的单链表结点s,利用尾插法插入到链表尾部 图示 代码 123456789101112131415161718192021//尾插法创建单链表singleLink* createSingleLink() &#123; int n, data; SingleLink*r; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;, &amp;n); SingleLink* L = (SingleLink*)malloc(sizeof(SingleLink)); L-&gt;next = NULL; r=L;//r始终指向末尾元素 for (int i = 0; i &lt; n; i++) &#123; SingleLink* s = (SingleLink*)malloc(sizeof(SingleLink)); printf(&quot;请输入第%d个节点的值(int)：&quot;, i + 1); scanf(&quot;%d&quot;, &amp;data); s-&gt;data = data; s-&gt;next = NULL; r-&gt;next = s; r = s;//r始终指向末尾元素 &#125; r-&gt;next = NULL;//将末尾元素的next指针域置位空 return L;&#125; 本算法的时间复杂度为O(n),n为单链表中数据结点的个数 特点:尾插法在进行创建单链表时,最后形成的链表的数据元素的顺序与最初的输入顺序完全相同 3.创建一个空链表 创建一个空链表很简单,只需要分配空间并肩将指针域初始化即可,就只有一个头结点 代码 123456//创建一个空链表SingleLink* createSingleLink() &#123; SingleLink* head = (SingleLink*)malloc(sizeof(SingleLink)); head-&gt;next = NULL; return head;&#125; 4.输出单链表 从第一个结点开始以此进行输出即可,注意循环结束条件 代码 123456789void outPut(SingleLink *head) &#123; printf(&quot;打印链表：&quot;); printf(&quot;\\n&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 5．输出单链表的长度 要想输出单链表的长度,则需要进行统计,我们只能从第一个元素开始进行遍历,利用一个变量用来记录经过了多少个结点,直至遍历到最后一个结点 代码 12345678int getLength(SingleLink* head) &#123; int len = 0; while (head-&gt;next) &#123; len++; head = head-&gt;next; &#125; return len;&#125; 6．判断单链表是否为空 判断单链表是否为空很简单,只需要判断头结点的指针域是否为NULL 代码1234//判断单链表h是否为空bool isEmpty(SingleLink *h) &#123; return h-&gt;next == NULL;&#125; 输出单链表第k个元素 大家在面对任何一个题目的时候,都要尽量的考虑周全.这里并没有告诉我们第k个元素一定存在,所以你一定要分情况处理.那就有两种情况:k&lt;1或k&gt;链表长度,这些都需要在代码里面进行体现 代码 1234567891011121314void outPutKth(SingleLink *h,int k) &#123; if(k&lt;1)return ;//如果k为小于1的数,肯定也是输入有误,直接结束程序 SingleLink* p = h-&gt;next; while (k--&amp;&amp;p) &#123;//让k的值跟随p一起变化 p = p-&gt;next; &#125; if (k) &#123;//如果k此时还不为0,说明我的链表都已经遍历完了,后续已经没有了,也就不存在第k个元素了 printf(&quot;该链表不存在第%d个元素&quot;,k); &#125; else &#123; printf(&quot;%d &quot;, p-&gt;data); &#125;&#125; 输出指定元素的位置 这是已知元素的值要我们在链表中找到它的位置,也就是单链表中的第几个元素.对于这类题,我们只能依次遍历该链表,并用一个变量来记录当前位置,该变量随着结点的遍历而自增. 代码 123456789int outPutPoint(SingleLink* h,int p) &#123; int k = 0; while (h-&gt;next) &#123; k++; if (h-&gt;next-&gt;data == p) break; h = h-&gt;next; &#125; return k;&#125; 在第k个元素位置上插入f元素 同样我们需要首先找到第k-1个结点,然后将f插入到其之后 代码 123456789101112void insert(SingleLink *h,int k,char f) &#123; if (k &lt; 1)return; SingleLink* p = h; while (--k) &#123; p = p-&gt;next; &#125; SingleLink* newP = (SingleLink*)malloc(sizeof(SingleLink)); newP-&gt;data = f; newP-&gt;next = p-&gt;next; p-&gt;next = newP;&#125; 删除单链表的第k个元素 同样我们需要找到第k-1个结点,并将该结点的指针域指向它的下下个结点 代码 1234567891011void delKth(SingleLink *h,int k) &#123; if (k &lt; 1)return; SingleLink* p = h-&gt;next; while (--k&amp;&amp;p) &#123;//一定要搞清楚先减减和后减减的区别,什么时候用先减减,什么时候用后减减 p = p-&gt;next; &#125; if (k) &#123; printf(&quot;该链表不存在第%d个元素&quot;,k); &#125; p-&gt;next = p-&gt;next-&gt;next;&#125; 双链表 双链表的结构 单链表只有指向后续结点的指针,在某一些应用场合可能并不是那么方便,于是便有了双链表,每一个结点都有两个指针域,分别指向前驱和后继. 双链表结构体 12345struct DLink &#123; int data; DLink* next; DLink* pre;&#125;; 1.创建双链表 同单链表一样,分为头插法与尾插法,只是在设个过程当中,我们要注意处理每个结点的两个指针域的链接 头插法 代码 1234567891011121314151617181920DLink* createDouLink() &#123; int n, data; DLink* head = (DLink*)malloc(sizeof(DLink)); head-&gt;next = NULL; head-&gt;pre = NULL; printf(&quot;请输入节点个数：n=&quot;); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;请输入第%d个节点值:&quot;, i + 1); scanf(&quot;%d&quot;, &amp;data); DLink* s = (DLink*)malloc(sizeof(DLink)); s-&gt;data = data; //头插法进行插入 s-&gt;next=head-&gt;next; if(head-&gt;next) head-&gt;next-&gt;pre=s; s-&gt;pre=head; head-&gt;next=s; &#125; return head;&#125; 尾插法 代码 123456789101112131415161718192021DLink* createDouLink() &#123; int n, data; DLink* head = (DLink*)malloc(sizeof(DLink)); DLink* r = head; head-&gt;next = NULL; head-&gt;pre = NULL; printf(&quot;请输入节点个数：n=&quot;); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;请输入第%d个节点值:&quot;, i + 1); scanf(&quot;%d&quot;, &amp;data); DLink* s = (DLink*)malloc(sizeof(DLink)); s-&gt;data = data; //尾插法进行插入 r-&gt;next = s; s-&gt;pre = r; r=s; &#125; r-&gt;next = NULL;//尾结点的指针域置为NULL return head;&#125; 2.双链表的插入操作： 在双链表中进行插入,因其涉及的指针较多,所以需要一步一步捋清楚,谁先谁后.下面演示在p结点之后插入结点s的详细步骤 代码 1234s-&gt;next = p-&gt;next;p-&gt;next-&gt;pre = s;s-&gt;pre = p;p-&gt;next = s; 需要注意的是,上面的语句不是唯一的,但是也不能任意调换顺序,第一步和第二步必须在第四步之前,否则在我们还没有操作p结点的后继结点就已经找不到了. 双链表的删除操作 在双链表中删除一个结点同样要考虑到指针的链接问题,下面演示删除q结点的详细步骤 需要注意的是,这里我们仅仅给出了要删除的结点q,如果我们给出的是要删除结点的前驱结点或是后继结点,我们又能否成功地进行删除,留给同学们自行思考. 循环链表&amp;&amp;静态链表 循环链表是另一种形式的链式存储结构.循环链表又循环单链表和循环双链表两种类型,循环单链表的结点类型和非循环单链表的结点类型相同,循环双链表与非循环双链表的结点类型相同 循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环 循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环 当循环双链表为空表时，其头结点的prior域和next域都等于Head。 静态链表：静态链表是用数组来描述线性表的链式存储结构,结点也有数据域data和指针域next,与前面所讲的链表中的指针不同,这里的指针式结点的相对地址(数组下标),又称游标.静态链表和顺序表一样,也要预先分配一块连续的内存空间. 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。 示例图 顺序表与链表对比 存储方式/特性对比 存取方式 结构 基本操作(增删查) 空间分配 顺序表 可顺序存储,可随机存取 逻辑上相邻,物理上也相邻 顺序表无序:若按值查找,时间复杂度O(n);若按序查找,随机特性,时间复杂度O(1); 顺序表有序:可采用折半查找,时间复杂度O(lgn)顺序表的删除,插入平均需要移动半个表长的元素 静态分配,预先分配过小,容易溢出;预先分配过大,内存浪费 链表 只能从表头顺序存取元素 逻辑上相邻,物理上不一定相邻 链表无论其有序还是无序都只能从表头元素依次查找,时间复杂度O(n),而插入.删除则只需要修改对应结点的指针域即可,时间复杂度O(1) 需要时分配,只要有空间就可以分配,操作灵活/高效 第三章：栈和队列 总述 从组成元素的逻辑关系来看,栈和队列都属于线性结构.栈和队列与线性表的不同之处在于它们的相关运算具有一些特殊性.更准确地说,一般线性表上的插入/删除运算不受限制,而栈和队列上的插入 删除运算均会受到某种特殊限制,因此栈和队列也称为操作受限的线性表. 栈 栈（Stack）定义：只允许在一端进行插入或删除操作的线性表。 示意图 相关术语: 栈顶（Top）：线性表允许进行插入和删除的那一端。 栈底（Bottom）：固定的，不允许进行插入和删除的另一端 基础操作: 入栈:push 出栈:pop 判断栈满:isFull 判断栈空:isEmpty 查看栈顶元素:top 销毁栈:destory 特点： 1.栈是受限的线性表，所以自然具有线性关系。 2.栈中元素后进去的必然先出来，即后进先出 实现方式: 顺序栈 栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。 顺序栈结构体 123456//栈struct Stack&#123; int* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;; 顺序栈的存放过程 顺序栈的操作 1.初始化栈:用户指定栈的大小,top指针初始化为-1,代表栈空 12345678//创建一个栈Stack *createStack_S(int size) &#123; Stack *stack = (Stack*)malloc(sizeof(Stack));//给栈分配空间 stack-&gt;arr = (NODETYPE*)malloc(sizeof(NODETYPE)*size);//给内存首地址分配空间，大小用户指定 stack-&gt;len = size;//栈容量 stack-&gt;top = -1;//栈顶下标，当前无元素，故为-1 return stack;&#125; 2.判满：如果top指针和数组长度-1相等则栈满 1234//判断栈满bool full(Stack *stack) &#123; return stack-&gt;top + 1 &gt;= stack-&gt;len;&#125; 3.判空：top指针等于-1代表当前栈为空 12345//判断栈空bool empty(Stack *stack) &#123; return stack-&gt;top == -1;&#125; 4.入栈:元素入栈首先要判断栈是否已满,未满才能放入数据,且要先将top指针+1,移向下一个位置,再将元素存入top下标所指位置 123456//入栈bool push(Stack *stack, NODETYPE p) &#123; if (full(stack)) return false; *(stack-&gt;arr + ++stack-&gt;top) = p; return true;&#125; 5.出栈：出栈的前提条件是栈中有元素,而后直接top指针减一 1234567//出栈bool pop(Stack *stack) &#123; if (empty(stack)) return false; stack-&gt;top--; return true;&#125; 6.读取栈顶元素：读取栈顶元素的前提是栈不空,而后直接返回top指针下标的元素,与出栈不同的是,不再对top指针进行减一操作. 12345//查看栈顶元素int top(Stack *stack) &#123; if (empty(stack)) return NULL; return *(stack-&gt;arr + stack-&gt;top);&#125; 7.销毁栈:先释放掉栈中的数组,再将栈空间释放 123456//销毁void destory(Stack *stack) &#123; free(stack-&gt;arr); free(stack);&#125; 共享栈 顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享 示意图 共享栈的结构:我们用一个大小为2的数组来分别表示0号栈和1号栈 12345struct Stack&#123; TYPE* arr; //内存首地址 int top[2]; //栈的下标&#125;; 共享栈的操作： 1.初始化栈:用户指定栈的大小,两个栈的栈顶指针都指向栈顶元素,top0=-1时0号栈为空,top1=MaxSize时1号栈为空 12345678//创建一个栈Stack *createStack_S(int size) &#123; Stack *stack = (Stack*)malloc(sizeof(Stack));//给栈分配空间 stack-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*size);//给内存首地址分配空间，大小用户指定 stack-&gt;top[0] = -1;//栈顶下标，当前无元素，故为-1 stack-&gt;top[1] = size;//栈顶下标，当前无元素，故为size return stack;&#125; 2.判满：画画图很容易发现当top1-top0=1时栈满 1234//判断栈满bool full(Stack *stack) &#123; return stack-&gt;top[1]-stack-&gt;top[0] == 1;&#125; 3.判空：top0指针等于-1代表0号栈为空;top1指针等于MaxSize时代表1号栈为空 12345678910//判断栈空bool empty(int i,Stack *stack,int size) &#123;//i为栈号 switch (i) &#123; case 0: return stack-&gt;top[0] == -1; case 1: return stack-&gt;top[1] == size; &#125;&#125; 4.入栈:元素入栈首先要判断栈是否已满,未满才能放入数据,然后判断要入的栈,且要先将top指针+1,移向下一个位置,再将元素存入top下标所指位置 1234567891011//入栈bool push(Stack *stack, TYPE data,int i) &#123; if (full(stack)) return false; switch (i) &#123; case 0: *(stack-&gt;arr + ++stack-&gt;top[i]) = data; case 1: *(stack-&gt;arr + --stack-&gt;top[i]) = data; &#125; return true;&#125; 5.出栈：出栈的前提条件是栈中有元素,而后判断哪个栈要出栈,直接top指针减一 123456789101112//出栈bool pop(int i,Stack *stack,int size) &#123; if (empty(i,stack,size)) return false; switch (i) &#123; case 0: stack-&gt;top[i]--; case 1: stack-&gt;top[i]++; &#125; return true;&#125; 链式栈 栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。 示意图: 链栈的结构体:所谓链栈,就是利用链表来模拟栈,所以我们这里的top指针为链表结点,它作为头指针指向头结点,从而栈顶元素为top-&gt;next.当然你也可以将top指向栈顶元素,因人而异,没有对错,重在理解. 12345678910//单链表struct singleLink &#123; NODETYPE data; singleLink* next;&#125;;//链栈struct LinkStack &#123; //int data; singleLink* top;&#125;; 链栈的各类操作 初始化链栈:如下所示,我们需要初始化一个链表,然后将top指针赋值为头指针 123456789//创建链栈LinkStack* createStack_L() &#123; singleLink* h; LinkStack* ls = (LinkStack*)malloc(sizeof(LinkStack)); singleLink* createSingleLink(); h = createSingleLink(); ls-&gt;top = h; return ls;&#125; 入栈:其实就是利用头插法,将新节点插入链表 123456789//入栈bool push(LinkStack* ls, NODETYPE data) &#123;//栈顶插入 singleLink* newd = (singleLink*)malloc(sizeof(singleLink)); newd-&gt;data = data; newd-&gt;next = ls-&gt;top-&gt;next; ls-&gt;top-&gt;next = newd; return true;&#125; 出栈:将栈顶元素摘出来,注意防止断链 12345678//出栈bool pop(LinkStack* ls) &#123; if (!ls-&gt;top-&gt;next)return false; singleLink* p = ls-&gt;top-&gt;next; ls-&gt;top-&gt;next = ls-&gt;top-&gt;next-&gt;next; free(p); return true;&#125; 查看栈顶元素 12345//查看栈顶元素NODETYPE top(LinkStack* ls) &#123; if (!ls-&gt;top-&gt;next) return NULL; return ls-&gt;top-&gt;next-&gt;data;&#125; 特点 1.链栈一般不存在栈满的情况。 2.空栈的判定条件通常定为top-&gt;next==NULL；当然也具体看你如何定义栈顶 队列 队列(Queue)定义:队列是只允许在一端进行插入，而在另一端进行删除的线性表 示意图: 相关术语: 队头（Front）：允许删除的一端，又称为队首。 队尾（Rear）： 允许插入的一端。 基础操作: 判断队空 判断队满 入队 出队 特点: 队列同样是受限的线性表,具有线性关系 先进入队列的元素必然先出来,即先进先出 实现方式: 顺序队列:队列是线性表的特例，那队列的顺序存储也是线性表顺序存储的简化。队列的顺序存储结构也叫作顺序队列 。 (为使空间合理利用,我们默认采用循环队列) 顺序队列结构体: 12345//顺序队列struct Squeue &#123; NODETYPE* arr; int front, rear;&#125;; 顺序队列的存放过程: 循环队列 循环队列的基本操作: 初始化队列:利用数组,且进行循环利用空间,初始化时将front与rear均设为0,代表队列空,与之对应的就是我们牺牲一个存储单元来判断队满,后续介绍 12345678//创建队列Squeue *createQueue(int n) &#123; Squeue *sq = ( Squeue *)malloc(sizeof( Squeue)); sq-&gt;arr = (NODETYPE *)malloc(sizeof(NODETYPE)*n);//数组大小 sq-&gt;front = 0; sq-&gt;rear = 0; return sq;&#125; 判满:判断队满(这里采用牺牲一个存储单元来实现,约定队头指针在队尾指针的下一个位置作为队满的标志) 123bool isFull(Squeue *sq, int maxSize) &#123; return (sq-&gt;rear + 1) % maxSize == sq-&gt;front;&#125; 判空:当队头指针与队尾指针重合时队列空 1234//判断队空bool isEmpty(Squeue *sq) &#123; return sq-&gt;front == sq-&gt;rear;&#125; 统计队列中的元素个数: 12345678/* 情况一: 当rear大于front时，循环队列的长度：rear-front 情况二: 当rear小于front时，循环队列的长度:分为两部分计算 0+rear 和 Quesize-front , 将两部分的长度合并到一起即为: rear-front+Quesize 所以将两种情况合为一种，即为: 总长度是(rear-front+Quesize)%Quesize */int count(Squeue *sq, int maxSize) &#123; return (sq-&gt;rear - sq-&gt;front + maxSize) % maxSize;&#125; 入队: 1234567//入队bool enQueue(Squeue *sq, NODETYPE data, int maxSize) &#123; if (isFull(sq, maxSize)) return false; sq-&gt;arr[sq-&gt;rear] = data; sq-&gt;rear = (sq-&gt;rear + 1) % maxSize; return true;&#125; 出队 1234567//出队bool deQueue(Squeue *sq, NODETYPE*data,int maxSize) &#123; if (isEmpty(sq)) return false; *data = sq-&gt;arr[sq-&gt;front]; sq-&gt;front = (sq-&gt;front + 1) % maxSize; return true;&#125; 循环队列判空判满的三种方式: 代码中采用的方式,牺牲一个存储单元.front==rear为空,(rear-front+maxsize)%maxsize 在队列结构体中新增表示元素个数的数据成员.这样的话,队空的条件就为size0,队满的条件就为sizemaxsize 在队列结构体中新增tag数据成员,用以区分队满还是队空.tag等于0时,同判断front==rear和tag的值 链式队列 队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。 链式队列示意图 不带头结点的链式队列,出队时,首先判断队是否为空,若不空,则取出对头元素,将其从链表中摘除,并让front指向下一个结点(若该结点为最后一个结点,则置front和rear都为null).入队时,建立一个新结点,将新结点插入到链表的尾部,并让rear指向这个新插入的结点(若原队列为空队,则令front也指向该结点). 我们可以发现,不带头结点的链式队列在操作上往往十分麻烦,因此我们通常将链式队列设计成一个带头结点的单链表,这样插入与删除操作就统一了. 链式队列的结构体 123456789//单链表struct singleLink &#123; NODETYPE data; singleLink* next;&#125;; `````````````````````````````````````````````````````````````````//链队struct LinkQueue &#123; singleLink* front, * rear;&#125;; 链式队列的基本操作 初始化链式队列: 123456789//创建链队LinkQueue* create() &#123; singleLink* h; LinkQueue* lq = (LinkQueue*)malloc(sizeof(LinkQueue)); singleLink* createSingleLink(); h = createSingleLink(); lq-&gt;front = lq-&gt;rear = h; return lq;&#125; 判空: 1234//判断空bool isEmpty(LinkQueue* lq) &#123; return lq-&gt;front == lq-&gt;rear;&#125; 1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的尾插入操作是一致的。 12345678910//入队bool enQueue(LinkQueue* lq, NODETYPE data) &#123;//队尾插入 singleLink* newd = (singleLink*)malloc(sizeof(singleLink)); newd-&gt;data = data; lq-&gt;rear-&gt;next = newd; lq-&gt;rear = newd; lq-&gt;rear-&gt;next = NULL; return true;&#125; 2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。 123456789101112//出队bool deQueue(LinkQueue* lq, NODETYPE* data) &#123; if (isEmpty(lq))return false; singleLink* p = lq-&gt;front-&gt;next;//保存下一个节点 *data = lq-&gt;front-&gt;next-&gt;data;//取出队首节点值 lq-&gt;front-&gt;next = p-&gt;next;//删除队首节点 if (lq-&gt;rear == p) &#123; lq-&gt;rear = lq-&gt;front; &#125; free(p); return true;&#125; 双端队列 双端队列是指允许两端都可以进行入队和出队操作的队列 栈的应用 1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。 算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。 代码 2、表达式求值： * 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。 3、递归： 要理解递归，你要先理解递归，直到你能理解递归。 如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。 1.阶乘 时间复杂度：O(NlogN) 2.斐波那契数列 时间复杂度 O(2^n) 概要: 如何将中缀表达式转换成后缀表达式？ 1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加) 2.把运算符移到对应的括号后。 3.去掉括号。 例子 第四章：树 树的基本概念 树的定义 树是由n个(n≥0)个结点(或元素)组成的有限集合 当n=0时,称作空树 若n&gt;0,在这n个结点中有且仅有一个结点作为树的根结点,简称为根 若n&gt;1,除根结点以外的其他结点克分为m(m≥0)个互不相交的有限集T1,T2,…,Tm,其中每个子集本身又是一颗符合本定义的树,称为根结点的子树. 显然,树的定义是递归的,因为在树的定义中又用到了树的定义.树既是一种逻辑结构,它同时又是一种分层结构 基本术语 结点的度与树的度:树中的某个结点的子树个数称为该结点的度;树中所有结点的度中的最大值称为树的度,通常将度为m的树称为m次树,如上图是一棵3次树. 分支结点与叶子结点:树中度不为0的结点称为非终端结点,也称为分支结点.度为0的结点称为叶子结点.在分支节点中,每个结点的分支数就是该结点的度.如对于度为1的结点,其分支数为1,被称为单分支结点;对于度为2的结点,称为双分支结点,以此类推.如上图所示:A B C D G 是分支结点，其余结点是叶子结点 路径与路径长度：树中的两个结点的路径就是这两个结点之间所经过的结点序列所构成。而路径长度则是路径上所经过的边的个数 孩子结点、双亲结点、兄弟结点：在一棵树中，每个结点的后继结点被称为该结点的孩子结点。如C是A的孩子结点。相应的，该结点称为孩子结点的双亲结点。具有同一双亲结点的孩子结点互为兄弟结点。 结点层次和树的高度：结点的层次是从树根开始定义，根结点为第一层，其孩子结点为第二层，以此类推。双亲在同一层次的结点互为堂兄弟。树的深度（高度）是树中结点的最大层数，上图中树的高度为4. 有序树和无序树：若树中各结点的子树是按照一定的次序从左向右安排的，且相对次序是不能随意变换的，则称为有序树，否则称为无序树。默认有序树。 森林:n(n≥0)个互不相交的树的集合称为森林。森林和树要结合起来理解，把树的根去掉，其余子树就变成了森林，反之，把m(m&gt;1)棵独立的树上加上一个根结点，并把这m棵树作为该结点的子树，则森林就变成了一棵树。 树的性质 1.树中的结点数等于所有结点的度数加1。 证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。 假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n=b+1。而分支数b也就是所有结点的度数，证毕。 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。 证明：（数学归纳法） 首先考虑i=1的情况：第一层只有根结点，即一个结点，i=1带入式子满足。 假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。 ……… … i-1层 ……… 又因为树的度为m,所以对于第i-1层的每个结点，最多 有m个孩子结点。所以第i层的结点数最多是i-1层的m 倍，所以第i层上最多有m ^(i-1)个结点。 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) 树的存储结构 顺序存储结构 双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。 链式存储结构 孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表； 如果是叶子结点，那这个结点的孩子单链表就是空的； 然后n个单链表的的头指针又存储在一个顺序表（数组）中。 孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结 点的第一个孩子结点和这个孩子结点的右兄弟结点。 二叉树 定义 二叉树是n（n≥0）个结点的有限集合： ① 空二叉树，即n=0。 ② 由一个根结点和两个互不相交的被称为根的左子树 和右子树组成。左子树和右子树又分别是一棵二叉树。 1.每个结点最多有两棵子树。 2.左右子树有顺序 两个易混概念：二叉树和度为2(2次树)的树 度为2的树中至少有一个结点的度为2，而二叉树没有这个要求 度为2的树不区分左右子树，而二叉树是严格区分左右子树的 二叉树的五种基本形态： 1.空树 2.只有一个根结点 3.根结点只有左子树 4.根结点只有右子树 5.根结点既有左子树又有右子树 特殊二叉树 1.满二叉树:在一颗二叉树中，如果所有分支结点都有左孩子结点和右孩子结点，并且叶子结点都集中在二叉树的最下一层，这样的二叉树称作满二叉树。非空满二叉树的特点： 叶子结点都在最下一层 只有度为0和度为2的结点 常对满二叉树进行编号：约定编号从树根为1开始，按照层数从小到大、同一层次从左到右的次序进行，这样，对于编号为i的结点，若有双亲，则双亲编号为 ⌊i/2⌋\\lfloor i/2 \\rfloor ⌊i/2⌋ 若有左孩子，则左孩子为2i；若有右孩子，则右孩子为2i+1。 2.完全二叉树：若二叉树中最多只有最下面两层的结点的度数可以小于2，并且最下面一层的叶子结点都依次排列在该层最左边的位置上，这样的二叉树称为完全二叉树。非空完全二叉树的特点： 叶子结点只可能在最小面两层中出现； 对于最大层次的叶子结点，都依次排列在该层最左边的位置上； 如果有度为1的结点，只可能有一个，且该结点只有左孩子没有右孩子； 按层序编号时，一旦出现编号为i的结点是叶子结点或只有左孩子，则编号大于i的结点均为叶子结点； 当节点总数n为奇数时，n1=0，当结点总数n为偶数时，n1=1 3.二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一颗二叉排序树。 4.平衡二叉树：树上任意一个结点的左右子树的高度差不超过1。 二叉树的性质 1.非空二叉树上叶子结点数等于双分支结点数加1 证明:设二叉树上的叶子结点数为n0n_0n0​,单分支结点数为n1n_1n1​、双分支结点数为n2n_2n2​,总结点数为nnn(如果没有特别指出,后面均采用这种设定),则总结点数n=n0+n1+n2n=n_0+n_1+n_2n=n0​+n1​+n2​。在一棵二叉树中,所有结点的分支数(即所有结点的度之和)应等于单分支结点数加上双分支结点数的两倍,即总的分支数=n1+2n2n_1+2n_2n1​+2n2​。 由于二叉树中除了根结点以外,每个结点都有唯一的一个分支指向它,因此在二叉树中总的分支数=n−1n-1n−1。 从而： {n=n0+n1+n2n分支=n1+2n2n分支=n−1⟹n1+2n2=n0+n1+n2−1⟹n0=n2+1\\begin{cases} n = n_0+n_1+n_2\\\\ n_{分支}=n_1+2n_2\\\\ n_{分支}=n-1 \\end{cases} \\Longrightarrow n_1+2n_2=n_0+n_1+n_2-1 \\Longrightarrow n_0=n_2+1 ⎩⎪⎨⎪⎧​n=n0​+n1​+n2​n分支​=n1​+2n2​n分支​=n−1​⟹n1​+2n2​=n0​+n1​+n2​−1⟹n0​=n2​+1 由上述3个等式可得n0=n2+1n_0=n_2+1n0​=n2​+1。 2.非空二叉树上第K层上至多有2k−12^{k−1}2k−1个结点（K≥1） 3.高度为H的二叉树至多有2^H-1个结点（H≥1） 4.具有N个（N&gt;0）结点的完全二叉树的高度为⌈log2(N+1)⌉\\lceil log_2(N+1)\\rceil⌈log2​(N+1)⌉或⌊log2N⌋+1\\lfloor log2N\\rfloor+1⌊log2N⌋+1。 二叉树的存储结构 顺序存储 二叉树的顺序存储结构就是用一组地址连续的存储单元来存放二叉树的数据元素,因此必须确定好树中各数据元素的存放次序,使得各数据元素在这个存放次序中的相互位置能反映出数据元素之间的逻辑关系。 对于完全二叉树和满二叉树,树中结点的层序编号可以唯一地反映出结点之间的逻辑关系,所以可以用一维数组按从上到下、从左到石的顺序存储树中的所有结点值,通过数组元素的下标关系反映完全二叉树或满二叉树中结点之间的逻辑关系。 例如,上图所示的完全二叉树对应的顺序存储结构如下图所示,编号为i的结点值存放在数组下标为i的元素中(’#'表示空结点)。由于C/C++语言中的数组下标从0开始,这里为了一致性而没有使用下标为0的数组元素。 大家可以很容易发现对于满二叉树和完全二叉树而言，这样的做法是十分方便的，但是如果是一般的二叉树，我们若还想让下标满足完全二叉树的特性，就不得不增添许多的空结点，这就使得空间浪费严重。所以一般而言，对于一般二叉树采用下面介绍的链式存储方式。 链式存储 定义：二叉树的链式存储结构是指用一个链表来存储一颗二叉树，二叉树中的每一个结点用链表中的一个结点来存储。 结构：二叉树链式存储结构的标准存储结构如下 其中data表示值域，存放着对应的数据元素，lchild和rchild分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的地址 结构体 123456//二叉树struct biTree &#123; BNODETYPE data; biTree* lchild; biTree* rchild;&#125;; 示例图 特性：在含有n个结点的二叉链表中，含有n+1个空链域 证明：除根结点以外，其余结点都对应一条边，也就是会消耗掉一个指针域，总共消耗掉n-1个指针域，而每个结点有左右两个指针域，即共有2n个指针域，那么空链域即为2n-(n-1)=n+1 优点：节省存储空间，访问孩子结点方便 缺点：访问双亲结点不方便（可增加一个指向双亲的指针域，了解即可） 二叉树的遍历 概念：二叉树的遍历是指按照一定的次序访问二叉树中的所有结点，并且每个结点仅被访问一次。接下来以下图为例讲解相关遍历 先序、中序、后序遍历递归算法 先序遍历：ABEFCH 1）访问根结点； 2）先序遍历左子树； 3）先序遍历右子树。 123456789//先序递归遍历void preOrder(biTree* T) &#123; if (T != NULL) &#123; printf(&quot;%c &quot;, T-&gt;data); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125; 中序遍历：EBFAHC 1）中序遍历左子树； 2）访问根结点； 3）中序遍历右子树。 12345678//中序递归遍历void inOrder(biTree* T) &#123; if (T != NULL) &#123; inOrder(T-&gt;lchild); printf(&quot;%c &quot;, T-&gt;data); inOrder(T-&gt;rchild); &#125;&#125; 后序遍历：EFBHCA 1）后序遍历左子树； 2）后序遍历右子树； 3）访问根结点。 12345678//后序递归遍历void postOrder(biTree* T) &#123; if (T != NULL) &#123; postOrder(T-&gt;lchild); postOrder(T-&gt;rchild); printf(&quot;%c &quot;, T-&gt;data); &#125;&#125; 上面的代码中对于访问根结点采取的是直接输出根结点值，在实际应用中我们可以对其进行各类操作，如结点计数、删除结点等。对于递归的理解，一定要结合画图进行。 先序、中序、后序非递归遍历算法： 二叉树是一种递归数据结构，其先序、中序和后序遍历算法采用递归方式设计师理所应当的，但考试的时候也仍然有可能考到让你用非递归方式来进行解题的情况，所以我们同样需要去掌握这三种非递归遍历算法。 先序非递归遍历：由现先序遍历过程可知，先访问根结点，再遍历左子树，最后遍历右子树。所以先访问根结点及其所有左下结点，但是因为在二叉链表中并没有指向双亲结点的指针，所以我们需要将已访问过的结点存入栈中。此时栈顶结点要么没有左子树，要么左子树已遍历过，所以转向它的右子树，对右子树的处理与上述过程类似。 12345678910111213141516171819void preOrder(biTree *T, Stack *s) &#123;//先序遍历 biTree *p = T; bool empty(Stack *); bool push(Stack *, biTree *); biTree *top(Stack *); bool pop(Stack *); while (p || !empty(s)) &#123; if (p) &#123;//一路向左 printf(&quot;%c &quot;, p-&gt;data);//打印当前元素 push(s, p); p = p-&gt;lchild; &#125; else &#123; p = top(s); pop(s);//栈顶元素出栈 p = p-&gt;rchild;//向右寻找 &#125; &#125;&#125; 注：外循环中的条件是指针p不为空或者栈不为空，这是因为，p是指向当前所要访问元素，只要它不为空我们就要就行访问和入栈，当p一路向左直至为空的时候，说明此时应该转头去访问双亲结点（如果有）的右子树了，也就是这里我们要去判断栈是否为空，若不为空，我们便同样要进入循环，进行类似的操作。同学们对于这类较复杂的算法过程一定要手动进行模拟，不能光靠想。 代码过程图示 p指针的值 当前访问结点 当前栈的操作 当前栈内元素（栈底-&gt;栈顶） A A A入栈 A B B B入栈 A B E E E入栈 ABE NULL ABE E E出栈 AB NULL AB B B出栈 A F F F入栈 AF NULL AF F F出栈 A NULL A A A出栈 C C C入栈 C H H H入栈 CH … … … … 中序非递归遍历: 中序非递归算法是在前面先序遍历非递归算法的基础上修改的,中序遍历顺序是左子树 根结点 右子树 所以需要将根结点及其左下结点依次进栈,但还不能访问,因为它的左子树没有遍历.当达到根结点的最左下结点时,它是中序序列的开始结点,也是栈顶节点,出栈并访问它,然后转向它的右子树,对右子树的处理与上述过程类似. 12345678910111213141516171819void inOrder(biTree *T,Stack *s) &#123;//中序遍历 biTree *p = T; bool empty(Stack *); bool push(Stack *,biTree * ); biTree *top(Stack *); bool pop(Stack *); while (p||!empty(s)) &#123; if (p) &#123;//一路向左 push(s,p); p = p-&gt;lchild; &#125; else &#123; p = top(s); printf(&quot;%c &quot;,p-&gt;data);//打印栈顶元素 pop(s);//栈顶元素出栈 p = p-&gt;rchild;//向右寻找 &#125; &#125;&#125; p指针的值 当前访问结点 当前栈操作 当前栈内元素(栈底-&gt;栈顶) A A入栈 A B B入栈 AB E E入栈 ABE NULL ABE E E E出栈 AB NULL AB B B B出栈 A F F入栈 AF NULL AF F F F出栈 A NULL A A A A出栈 C C入栈 C H H入栈 CH NULL CH H H H出栈 C NULL C C C C出栈 NULL 程序结束 后序非递归遍历:和前面两种非递归遍历一样的思路,我们知道后序遍历的顺序是左子树 右子树 根结点.所以先将根结点及其左下结点依次进栈,既是栈顶结点p的左子树以遍历或为空,仍还不能访问结点p,因为它们的右子树没有遍历,只有当这样的p结点的右子树已遍历完才能访问结点p. 由此过程我们可以知道后序遍历它的算法的视线难度是大于前两者的,因为它的限定条件更多。 现在我们来模拟一下下图的一个遍历流程 首先A B E入栈，发现E没有左孩子也没有右孩子，输出E，E退栈，此时栈顶元素为B，访问B，发现B有右孩子,将右孩子F入栈,F同E,F输出并出栈,此时栈顶元素仍为B,但是我们刚刚将其右孩子已经输出,所以我们不再将其右孩子F入栈,直接输出B,此时栈顶元素为A,同样它存在右孩子且未被访问,所以我们要把其右孩子C入栈,这样不停循环,直至栈空… 这里就会比前两个遍历多出来一个问题需要我们进行考虑:我们如何判断栈顶元素的右孩子是否已经被访问呢?每当我们遇到问题的时候,我们首先应该去分析它的特点,然后根据其特点来制定相应的解决办法.我们可以发现,每当我们来到栈顶元素时,要么是从左孩子这边退回来,要么就是从右孩子这边退回来.也就是说,来到栈顶元素的前一个被访问的元素一定是它的孩子结点,现在我们的诉求是判断是否是栈顶元素的右孩子,那我们在每次访问输出结点时就将当前结点标记存储起来,当我需要退回到下一个栈顶元素时,我立马进行判断当前元素是否和我之前存储的结点相同,如果相同说明该栈顶元素的右子树已经被访问输出了,不用再管了,若不相同,说明其右子树需要进行遍历.下面给出示例代码: 123456789101112131415161718192021222324252627void postOrder(biTree *T, Stack *s) &#123;//后序遍历 biTree *p = T; biTree *r = (biTree*)malloc(sizeof(biTree)); bool empty(Stack *); bool push(Stack *, biTree *); biTree *top(Stack *); bool pop(Stack *); while (p || !empty(s)) &#123; if (p) &#123;//一路向左 push(s, p); p = p-&gt;lchild; &#125; else &#123; p = top(s); if (p-&gt;rchild&amp;&amp;r != p-&gt;rchild) &#123; p = p-&gt;rchild; &#125; else &#123; printf(&quot;%c &quot;, p-&gt;data);//打印栈顶元素 r = p;//r作为暂存指针,用以后续的右孩子判断 pop(s);//栈顶元素出栈 p = NULL;//这里一定要将p设为NULL，因为p的孩子已经遍历过了，不设置为NUll的话，又会将左孩子压入栈 &#125; &#125; &#125;&#125; 下面模拟上图的代码模拟流程: p指针的值 r指针的值 当前访问元素 当前栈操作 当前栈内元素 A NULL A入栈 A B NULL B入栈 AB E NULL E入栈 ABE NULL NULL E(没有右孩子) NULL E E出栈 AB NULL E AB B E AB F E F入栈 ABF NULL E ABF F(没有右孩子) F F F出栈 AB B(右孩子与r同) F B B出栈 A A(右孩子不等于r,继续向右遍历) B A C B C入栈 AC H B H入栈 ACH NULL B ACH H(没有右孩子) B H H出栈 AC C(没有右孩子) H C C出栈 A A(右孩子与r同) C A A出栈 程序结束 层次遍历：所谓层次遍历，就是按照视觉上一层一层的去进行遍历，如该图 层次遍历序列为：ABCEFH 我们可以发现，先访问的结点的左右孩子也要先进行访问，这与队列的特征相吻合，因此层次遍历可以采用队列来实现 层次遍历的过程是：先将根结点入队，在队不空时循环，从队列中出列一个结点p，访问它。若它有左孩子节点，将左孩子节点进队；若它有右孩子结点，将右孩子结点入队。如此操作直到队空为止。代码如下： 1234567891011121314void levelOrder(biTree *T,Squeue *sq,int maxSize) &#123; biTree *p = T;//工作指针 biTree *r = ( biTree *)malloc(sizeof( biTree));//暂存指针 bool enQueue(Squeue *, biTree *, int); bool isEmpty(Squeue *); bool deQueue(Squeue *, biTree **,int); enQueue(sq,p,maxSize);//根节点入队 while (!isEmpty(sq)) &#123; deQueue(sq,&amp;r,maxSize); printf(&quot;%c &quot;,r-&gt;data); if(r-&gt;lchild)enQueue(sq, r-&gt;lchild, maxSize); if (r-&gt;rchild)enQueue(sq, r-&gt;rchild, maxSize); &#125;&#125; 二叉树的基本运算 创建二叉树:大家想想我们在手画一颗二叉树的步骤,是不是先画出根结点,然后画出分支,再画出其孩子结点.如此循环往复.其实所有的算法代码都是我们实际问题的模拟.我们先画的根结点,那我们就采取先序遍历来创建出一颗二叉树.我们之前学习过先序遍历的递归代码,现在老师带领你们看看如何将最基本的递归遍历代码改造为创建一颗二叉树的代码. 首先,先序遍历的代码如下: 12345678//先序递归遍历void preOrder(biTree* T) &#123; if (T != NULL) &#123; printf(&quot;%c &quot;, T-&gt;data); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125; 首先我们应该由用户输入结点的值,我们应该由输入值来判断是否需要创建该结点,也就是需要一个条件用于退出递归,如下: 123456789101112131415biTree* create(int type) &#123;//这里我们采用先序创建一颗二叉树，type为节点类型：0代表int 1代表char biTree* T = NULL; BNODETYPE data; type ? printf(&quot;请输入当前节点值(char)：data=&quot;) : printf(&quot;请输入当前节点值(int)：data=&quot;); type ? scanf(&quot; %c&quot;, &amp;data) : scanf(&quot;%d&quot;, &amp;data);// if (data != &#x27;#&#x27; &amp;&amp; data != -1) &#123; T = (biTree*)malloc(sizeof(biTree)); T-&gt;data = data; T-&gt;lchild = NULL; T-&gt;rchild = NULL; T-&gt;lchild = create(type); T-&gt;rchild = create(type); &#125; return T;&#125; 可以看到,在第6行,我们会对用户输入的数据进行判定,我们人为规定,当用户输入&quot;#“或”-1&quot;时,代表当前结点为空,直接返回,作为上一层递归的结点的孩子.当输入不为其中之一时,代表这是一个实实在在的结点,我们应为其分配空间,并将数据域赋值为输入的值.如此递归下去,直至程序结束. 销毁二叉树 1234567void destoryBTree(biTree *T)&#123; if(T)&#123; destoryBTree(T-&gt;lchild); destoryBTree(T-&gt;rchild); free(T) &#125;&#125; 统计结点个数 12345678//统计节点个数void nodeNum(biTree* T, int* num) &#123; if (T != NULL) &#123; (*num)++;//注意这里++的优先级高于*，要加上括号 nodeNum(T-&gt;lchild, num); nodeNum(T-&gt;rchild, num); &#125;&#125; 求结点值为x的层次 12345678910//求结点值为x的层次void getXLevel(biTree* T, int x, int&amp; level, int count) &#123;//level获取最终的层次，count用于计数 if (T != NULL) &#123; if (T-&gt;data == x)//相等时，层次确定 level = count; getXLevel(T-&gt;lchild, x, level, count + 1);//每往下寻找，count便加一 getXLevel(T-&gt;rchild, x, level, count + 1); &#125;&#125; 求树的高度 12345678int getHigh(biTree *T) &#123; if (!T)return 0; int lDepth = getHigh(T-&gt;lchild); int rDepth = getHigh(T-&gt;rchild); int depth = lDepth &gt; rDepth ? lDepth+1 : rDepth+1; return depth;&#125; 求指定值为x的结点的双亲结点p 123456789101112//求指定值为x的结点的双亲结点pbiTree* findParent(biTree* T, int x) &#123;//采用先序递归遍历 static biTree* pre = NULL;//设立一个先驱结点 if (T) &#123; if (T-&gt;data != x) &#123;//当前结点不等于x，先驱更新 pre = T; &#125; findParent(T-&gt;lchild, x); findParent(T-&gt;rchild, x); &#125; return pre;&#125; 二叉树的构造 我们在这个小节假设二叉树的每个结点值为单个字符,而且所有结点值均不相同,同一颗二叉树具有唯一的先序序列/中序序列和后序序列,但不同的二叉树可能具有相同的先序序列/中序序列和后序序列 定理1:任何n(n≥0)个不同结点的二叉树,都可由它的中序序列和先序序列唯一地确定. 定理2:任何n(n≥0)个不同结点的二叉树,都可由它的中序序列和后序序列唯一地确定. 常考题型:给出先序和中序画出二叉树;给出后序和中序画出二叉树;给出层序和中序画出二叉树 例:先序 ABDEGCF 中序 DBEGACF 画出这颗二叉树 线索二叉树 概念:遍历二叉树的结果是得到一个所有结点的线性序列,无论是先序、中序还是后序，都使得所得序列中的每个结点（除了第一个结点和最后一个结点）都有一个直接前驱和一个直接后继。 为使其可以向链表一样可以轻松的得到结点的前驱与后继，我们很容易就想到利用二叉树中的空指针域用于存储前驱和后继信息。具体规则如下： 当某结点的左指针为空时，令该指针指向这个线性序列中该结点的前驱结点；当某结点的右指针为空时，令该指针指向这个序列中该结点中的后继结点，这样的指向该线性序列中的“前驱结点”和“后继结点”的指针称为“线索”。创建线索的过程称为线索化，拥有线索的二叉树称为线索二叉树。 大家需要思考一个问题，我们将空指针域作为一条线索存在，这是人为的定义，而在代码中的实现计算机仍然将它当做是左右孩子，所以我们必须得使用一些特殊的标记来让计算机明白什么时候是指针、什么时候是线索。这就引出了标志域tag。在二叉树结点结构中新增两个属性：ltag和rtag $ 左标志ltag=\\begin{cases} 0 \\quad表示lchild指向左孩子结点\\ 1\\quad 表示lchild指向前驱结点\\end{cases}$ $ 右标志ltag=\\begin{cases} 0 \\quad表示lchild指向右孩子结点\\ 1\\quad 表示lchild指向后继结点\\end{cases}$ 增加了标志域的结点的存储结构如下: ltag lchild data rchild rtag 增加了标志域的结点结构体如下: 1234567//线索二叉树struct biTree &#123; BNODETYPE data; biTree* lchild; biTree* rchild; int ltag, rtag;&#125;; 线索化二叉树:建立一颗线索二叉树,其实就是通过遍历将空指针域进行重新指向前驱或者后继的过程。 线索二叉树的代码实现（以中序线索二叉树为例） 中序线索二叉树是在已有二叉树的基础上通过中序遍历添加线索而得到，在遍历过程中，如果当前结点左孩子指针为空，则需要将其作为左线索，将其指向其前驱，而在我们定义的结点结构中并没有指向结点前驱的属性变量，所以我们需要在代码中时刻保持存储当前遍历结点的前驱结点，即我们初始化一个指针变量pre=NULL，该指针变量会随着结点的变动而变动，pre会一直是当前结点的前驱结点；另一方面，我们就可以去处理pre指针指向的结点的右孩子指针域，如果pre指针不指向空，并且其右孩子指针为空，说明该指针域可以作为线索存在，从而将该指针域指向其后继结点，即当前遍历结点。这样，我们就可以得到一颗中序线索二叉树。代码如下： 12345678910111213141516extern biTree* pre = NULL;void inThread(biTree *p ) &#123;//中序线索二叉树 if (p!=NULL) &#123; inThread(p-&gt;lchild); if (p-&gt;lchild==NULL) &#123;//如果左子树为空，建立前驱线索 p-&gt;lchild = pre; p-&gt;ltag = 1; &#125; if (pre!=NULL &amp;&amp; pre-&gt;rchild==NULL) &#123;//建立前驱结点的后继线索 pre-&gt;rchild = p; pre-&gt;rtag = 1; &#125; pre = p; inThread(p-&gt;rchild); &#125;&#125; 哈夫曼树和哈夫曼编码 哈夫曼树概述:在许多应用中经常将树中的结点赋予一个有某种意义的数值,称此数值为该结点的权.从根结点到该结点之间的路径长度与该结点上的权的乘积称为结点的带权路径长度.树中所有叶子结点的带权路径长度之和称为概述的带权路径长度,通常记为: WPL=∑i=1n0wiliWPL=\\sum_{i=1}^{n_0}w_il_i WPL=i=1∑n0​​wi​li​ 其中,n0n_0n0​ 表示叶子结点的个数,wi和liw_i和l_iwi​和li​分别表示第iii个叶子结点的权值和根到它之间的路径长度(即从根结点到该叶子结点的路径上经过的分支数). 在n0n_0n0​个带权叶子结点构成的所有二叉树中,带权路径长度WPL最小的二叉树称为哈夫曼树或最优二叉树.如下面的带权二叉树,它们的带权路径长度 {(a)WPL=1×2+4×3+5×3+6×3=47(b)WPL=1×3+4×3+5×2+6×1=31(c)WPL=1×2+4×2+5×2+6×2=32\\begin{cases}(a)WPL=1\\times2+4\\times3+5\\times3+6\\times3=47\\\\ (b)WPL=1\\times3+4\\times3+5\\times2+6\\times1=31\\\\ (c)WPL=1\\times2+4\\times2+5\\times2+6\\times2=32\\\\\\end{cases} ⎩⎪⎨⎪⎧​(a)WPL=1×2+4×3+5×3+6×3=47(b)WPL=1×3+4×3+5×2+6×1=31(c)WPL=1×2+4×2+5×2+6×2=32​ 显而易见,对于一组具有确定权值的叶子结点可以构造出多个具有不同带权路径长度的二叉树.也同样可以发现,b图是一颗哈夫曼树,它的带权路径长度最小. 哈夫曼树的构造:在哈夫曼树的构造中,一般会给出n个带有给定权值的结点,要求我们通过一定的算法将这n个结点构造成一颗二叉树,且这n个结点最后都是叶子结点,并且带权路径长度WPL最小.下面给出一般的构造哈夫曼树的算法步骤: (1)根据给定的n个权值(ω1,ω2,...ωn,\\omega_1,\\omega_2,...\\omega_n,ω1​,ω2​,...ωn​,),对应结点构成n棵二叉树的森林F=(T1,T2,...,Tn)F=(T_1,T_2,...,T_n)F=(T1​,T2​,...,Tn​) ,其中每颗二叉树Ti(1≤i≤n)T_i(1\\leq i\\leq n)Ti​(1≤i≤n),中都只有一个带权值为ωi\\omega_iωi​ 的根结点,其左右子树均为空. (2)在森林F中选取两颗结点的权值最小的子树分别作为左右子树构造一颗新的二叉树,并且置新的二叉树的根结点的权值为其左右子树上根的权值之和. (3)在森林F中,用新得到的二叉树代替这两棵树 (4)重复(2)和(3),直到F只含一棵树为止.这棵树便是哈夫曼树 下面给出一个示例: 定理1：对于具有n0n_0n0​个叶子结点的哈夫曼树，共有2n0−12n_0-12n0​−1个结点。 证明:在哈夫曼树的构造过程中，每次都是将两颗树合并为一棵树，所以哈夫曼树中不存在度为1的节点，即n1=0n_1 = 0n1​=0 . 由二叉树的性质可知，n0=n2+1n_0=n_2+1n0​=n2​+1 ,即n2=n0−1,则n=n0+n1+n2=n0+n2=n0+n0−1=2n0−1n_2 = n_0 -1 ,则 n = n_0 +n_1 +n_2 = n_0 +n_2 = n_0 +n_0 -1 = 2n_0 -1n2​=n0​−1,则n=n0​+n1​+n2​=n0​+n2​=n0​+n0​−1=2n0​−1. 哈夫曼树的结点类型定义：我们要清楚,结点的结构体的构建都是为了我们更好地去表述相应的构造算法,所以在这里我们要从算法的角度去分析结构体的构造. 大家可以想一想,在这里哈夫曼树应该用什么样的存储结构来表示呢?还是和之前二叉树那样链接的方式吗?显然不恰当,因为我们会重复利用这里由两个最小权值结点之和形成的新的结点,所以我们有双亲结点指向孩子结点的&quot;指针&quot;,而我们的哈夫曼编码是需要去判断当前结点是其双亲结点的左孩子亦或右孩子,一般而言,左孩子编码&quot;0&quot;,右孩子编码&quot;1&quot;.这样的话我们就必须有从孩子结点指向双亲的&quot;指针&quot;.也就是说一般性的二叉树的无法满足我们这里的要求. 在这里,我们设计一种新的结构体: 123456789101112# define N 30 //叶子结点数的最大值# define M 2 * N - 1 //所有结点数的最大值# define MAX 32767/*哈夫曼树的类型定义*/typedef struct &#123; char data; //存放结点字符 int weight; //结点的权值 int parent; //双亲的下标 int LChild; //左孩子结点的下标 int RChild; //右孩子结点的下标&#125;HTNode, HuffmanTree[M + 1]; //HuffmanTree是一个结构数组类型，0号单元不用 如上代码所示:在这个哈夫曼树结点结构体的构成中包含着结点本身的信息、结点的权值、结点的双亲下标、及其左右孩子的下标。这样我们就可以进行构造算法的设计了。 哈夫曼树的构造算法：这里先贴出哈夫曼树的构造代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/*哈夫曼树及哈夫曼编码实现*/# include&lt;stdio.h&gt;# include&lt;malloc.h&gt;# include&lt;string.h&gt;# define N 30 //叶子结点数的最大值# define M 2 * N - 1 //所有结点数的最大值# define MAX 32767/*哈夫曼树的类型定义*/typedef struct &#123; char data; //存放结点字符 int weight; //结点的权值 int parent; //双亲的下标 int LChild; //左孩子结点的下标 int RChild; //右孩子结点的下标&#125;HTNode, HuffmanTree[M + 1]; //HuffmanTree是一个结构数组类型，0号单元不用HuffmanTree ht;/*在ht[1]至ht[n]的范围内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2*/void Select(HuffmanTree ht, int n, int* s1, int* s2) &#123; int i, min1 = MAX, min2 = MAX; *s1 = 0; *s2 = 0; for (i = 1; i &lt;= n; i++) &#123; if (ht[i].parent == 0) &#123; if (ht[i].weight &lt; min1) &#123; min2 = min1; *s2 = *s1; min1 = ht[i].weight; *s1 = i; &#125; else if (ht[i].weight &lt; min2) &#123; min2 = ht[i].weight; *s2 = i; &#125; &#125; &#125;&#125;/*创建哈夫曼树算法*/void CrtHuffmanTree(HuffmanTree ht, int w[],char data[], int n) &#123; //构造哈夫曼树ht[M+1],w[]存放n个权值 int i; for (i = 1; i &lt;= n; i++) &#123; //1至n号单元存放叶子结点，初始化 ht[i].data = data[i - 1]; ht[i].weight = w[i - 1]; ht[i].parent = 0; ht[i].LChild = 0; ht[i].RChild = 0; &#125; int m = 2 * n - 1; //所有结点总数 for (i = n + 1; i &lt;= m; i++) &#123; //n+1至m号单元存放非叶结点，初始化 ht[i].data = &#x27;#&#x27;; ht[i].weight = 0; ht[i].parent = 0; ht[i].LChild = 0; ht[i].RChild = 0; &#125; /*初始化完毕，开始创建非叶结点*/ int s1, s2;//当前最小两值的序号 for (i = n + 1; i &lt;= m; i++) &#123; //创建非叶结点，建哈夫曼树 Select(ht, i - 1, &amp;s1, &amp;s2);//在ht[1]至ht[i-1]的范围内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2 ht[i].weight = ht[s1].weight + ht[s2].weight; ht[s1].parent = i; ht[s2].parent = i; ht[i].LChild = s1; ht[i].RChild = s2; &#125;&#125;/*哈夫曼编码*/void CrtHuffmanCode(HuffmanTree ht, int n) &#123; //从叶子结点到根，逆向求每个叶子结点(共n个)对应的哈夫曼编码 char* cd; cd = (char*)malloc(n * sizeof(char)); //分配当前编码的工作空间 for (int i = 1; i &lt;= n; i++) &#123; //求n个叶子结点对应的哈夫曼编码 int start = n - 1, c = i, p = ht[i].parent; while (p != 0) &#123; --start; if (ht[p].LChild == c) //左分支标0 cd[start] = &#x27;0&#x27;; else cd[start] = &#x27;1&#x27;; //右分支标1 c = p; //向上倒堆 p = ht[p].parent; &#125; printf(&quot;%c的编码：&quot;, ht[i].data); for (int j = 0; j &lt; n; j++) &#123; if (cd[j] == &#x27;0&#x27; || cd[j] == &#x27;1&#x27;) &#123; printf(&quot;%c&quot;, cd[j]); //编码输出 &#125; &#125; printf(&quot;\\n&quot;); memset(cd, -1, n);//将cd初始化 &#125;&#125;int main() &#123; int i, w[5] = &#123; 2,3,5,7,8 &#125;; char str[5] = &#123; &#x27;c&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;a&#x27;,&#x27;t&#x27; &#125;; CrtHuffmanTree(ht, w, str,5); printf(&quot;哈夫曼树各结点值：\\n&quot;); for (i = 1; i &lt;= 5; i++) printf(&quot;%c &quot;, ht[i].data); printf(&quot;\\n&quot;); CrtHuffmanCode(ht, 5); return 0;&#125; 说明:在一组字符的哈夫曼编码中,任一字符的哈夫曼编码不可能是另一字符哈夫曼码的前缀. 并查集: 什么是并查集:所谓并查集，是用来解决元素分组问题的一种数据结构，主要有两个功能：合并两个不相交集合、查询两个元素是否在同一个集合中。也正因为是这两个功能，所以该数据结构叫做并查集。 形象地理解并查集：并查集的重要思想就在于要用集合中的一个元素来代表集合。就好比把集合比喻成帮派，而代表元素则是帮主。我们利用这个比喻来看看并查集是如何运作的。 初始状态，所有人自成一派，自己就是帮主（对于只有一个元素的集合，代表元素自然也只能是那个唯一的元素） 现在，1号与4号进行比武，假设1号赢，那么按照江湖规矩，4号就得当1号的小弟（合并），此时1号帮派就有两个人了，帮主（代表元素就是1号） 过了一段时间，5号选手想和想和4号pk，首先他们得看看他们得帮主是不是同一个人，如果是同一个人那就不能开战，发现不是同一人，5号的帮主就是他自己，而4号帮主是1号，1号出马迎接5号的挑战，假设仍然1号胜出，那么5号也必须加入1号帮派，1号仍然作为帮主。 假设2 3 6 号也同样进行了激烈的帮派斗争，形成以下格局 现在江湖上形成了两强局面，某一天4号和6号想要pk。首先他们的帮主不是同一人，所以他们喊各自的帮主，1号和3号出手，假设1号胜利，则3号拜入1号门下，当然2号和6号作为3号小弟也成为了1号的小弟。 善于观察的同学已经发现这其实是一个树状的结构，要寻找集合的代表元素，只需要一步一步的向上寻找即可，可以发现，代表元素的箭头是永远指向自己的，这也是我们去判断是否找到代表元素的一个条件。 并查集代码： 我们上面的描述可以知道，我们的每一个结点都要能够找到他的双亲结点，而且最开始的祖先结点就是结点本身。鉴于此我们可以设置一个数组用来达到此目的，即将数组下标代表各元素，而下标对应的值为其双亲序号，这样层层寻找就可以找到其祖先元素。由此并查集代码实现可分为以下三个部分： 初始化一个并查集 12345678int* init(int n)&#123; int *fa = (int *)malloc(sizeof(int)*G-&gt;numV);//并查集数组 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; fa[i] = i;//最开始将每个节点的祖先设置为自己 &#125; return fa;&#125; 查找祖先元素 123456int findAncestor(int *fa, int i) &#123; if (fa[i] == i)return i;//找到返回 else &#123; return findAncestor(fa,fa[i]); &#125;&#125; 合并两个集合，即将两个“帮主”进行合并,即将前者的父节点设为后者即可 12345void unionn(int *fa, int i, int j) &#123; int i_a = findAncestor(fa, i); int j_a = findAncestor(fa, j); fa[i_a] = j_a;//i的祖先指向j的祖先&#125; 路径压缩：上面的并查集的效率是比较低的，例如，如果我们遇到了下面的场景： 在合并2,3 时，我们找到2 的祖先是1，然后将1的祖先设置为3，同理第二步时将3的祖先设置为4.大家可以发现,这样的一种做法会使得我们的查询效率变得十分低下,假如有10000个数,那么最大的查找次数就会为10000次.而我们也可以发现,我们的目的是找到&quot;代表元素&quot;,那直观地来看,我们完全可以将我的父亲节点直接设置为&quot;代表元素&quot;,就像这样： 这样我们每次就可以以0(1)的时间复杂度找到我们的“代表元素”。这种方法也叫做路径压缩，现在我们看看代码应该如何实现，如下所示： 12345678910111213int findAncestor(int *fa, int i) &#123; if (fa[i] == i)return i;//找到返回 else &#123; fa[i]=findAncestor(fa,fa[i]);//父节点设为“代表元素” return fa[i]; &#125;&#125;//上述代码也可以进行简化int findAncestor(int *fa, int i) &#123; return fa[i]==i ? i: ( fa[i]=findAncestor(fa,fa[i])); //三元运算符&#125; 第五章：图 图的基本概念 定义： 图是由两个集合，顶点集V(vertex)和边集E(edge)组成，记为G=(V，E)，其中，V(G)是图中顶点的有限集合，E(G)是图中两个顶点连接形成的边的有限集合。 注：在我们的这些数据结构中，线性表可以使空表，树也可以是空树，但是图不能是空图，至少得有一个顶点，图中可以没有边 分类 有向图 有向边（弧）的有限集合 弧是顶点的有序对 &lt;v,w&gt; v是弧尾，w是弧头 v邻接到w或w邻接自v 无向图 无向边的有限集合 边是顶点的无序对 （v,w） （v,w）=(w,v) w，v互为邻接点 简单图 1.不存在顶点到自身的边 2.同一条边不重复出现 多重图 若图G中某两个结点之间的边数多于一条，又允许顶点通过同一个边和自己关联，也就是自环 完全图 无向完全图 任意两个顶点之间都存在边，对于无向完全图，包含n(n−1)/2n(n-1)/2n(n−1)/2条边。 有向完全图 如果任意两个顶点之间都存在方向相反的两条弧，对于有向完全图，包含n(n−1)n(n-1)n(n−1)条边 子图 设有两个图G=(V,E)和G1=(V1,E1),若V1是V的子集,E1是E的子集,则称G1是G的子图. 注:子图首先一定得是个图,也就是说,随便地从G中取出顶点和边不一定就是子图的 连通 连通图 与连通分量: 连通:在无向图中,若从顶点m到顶点n存在路径,则称顶点m和顶点n是连通的 连通图:若图中任意两个顶点之间均有路径,则称该图为连通图 连通分量:无向图中的极大连通子图成为该图的连通分量 极大:代表在子图中顶点足够多,依附的边也足够多. 显然一个连通图的极大连通子图就是它本身 非连通图存在多个连通分量 找连通分量的方法： 从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图 强连通图和强连通分量: 强连通图:在有向图中,若图中任意顶点之间都是连通的,则称该有向图是强连通图 强连通分量:有向图中的极大强连通子图称为该有向图的强连通分量 找强连通分量: (1) 在图中找有向环 (2)扩展该有向环:如果某个顶点到该环中的任一顶点有路径,并且该环中的任一顶点到这个顶点也有路径,则加入这个顶点. 连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图 生成树去掉一条边则变成非连通图，加上一条边就会形成回路。 度：以该顶点为一个端点的边数目 无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v) 有向图中顶点V的度分为出度和入度 入度（ID）是以顶点v为终点的有向边的数目 出度（OD）是以顶点V为起点的有向边的数目 简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路 权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网 路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度 回路（环）：第一个和最后一个顶点相同的路径称为回路或者环 距离：从顶点u到v的最短路径长度。不存在路径则为无穷 图的存储结构 邻接矩阵（顺序存储） 图的邻接矩阵是一种采用邻接矩阵数组表示顶点之间相邻关系的存储结构。邻接矩阵说白了就是一个二维数组，数组下标代表顶点序号，数组值，即行列交叉处代表两个顶点之间的权值，如果是无权图，那么我们简单设置为1即可。如果两顶点之间没有边，那我们就可以将数组对应位置设置为∞\\infty∞ 或者0都可以。 不带权无向图 对于上面的无向图所对应的邻接矩阵为： 不带权有向图： 邻接矩阵 带权无向图： 邻接矩阵 带权有向图 邻接矩阵 图的邻接矩阵结构体的定义如下: 12345678910#define MAXSIZE 100//邻接矩阵节点类型 根据需要可设为整型或字符型#include &quot;basicnodeType.h&quot;//邻接矩阵struct AMGraph &#123; BNODETYPE Vertex[MAXSIZE]; int Edge[MAXSIZE][MAXSIZE]; int numV, numE;//顶点、边数量&#125;; 邻接矩阵的特点如下: 图的邻接矩阵表示唯一 对于含有n个顶点的图,当采用邻接矩阵存储时,无论是有向图还是无向图,也无论边的数量是多少,其存储空间都为O(n²),所以邻接矩阵适合于存储边的数目较多的稠密图 无向图的邻接矩阵数组一定是对称的,因此可以采取压缩存储的思想,在存放邻接矩阵数组时只需存放上(下)三角部分的元素即可 对于无向图,邻接矩阵数组的第iii 行或第iii列非零元素、非∞\\infty∞ 元素的个数正好是顶点iii的度 对于有向图,邻接矩阵数组的第iii 行或第iii列非零元素、非∞\\infty∞ 元素的个数正好是顶点iii的出度(或入度) 在邻接矩阵中,判断图中两个顶点之间是否有边或者求两个顶点之间边的权的执行时间为O(1)。所以在需要提取边权值的算法中通常采用邻接矩阵存储结构 邻接表（链式存储） 图的邻接表（adjacency list）是一种顺序与链式存储相结合的存储方法。看看下面这个例子 对邻接表的理解： 首先 十字链表（有向图） 邻接多重表（无向图） 图的遍历 概念:给定图G,从任意顶点出发,按照某种搜索方法沿着图的边去访问图中的所有顶点,使每个顶点只被访问一次,称这个过程为图的遍历。 在图的遍历中：我们需要注意两件事 如果是连通图或者强连通图，那么我们一趟遍历就可以访问完所有的顶点 在图中进行遍历是比较复杂的，其一，从初始点到其他顶点可能存在着多条路径，其二，从某顶点开始进行搜索，访问某一顶点后，可能因为存在另一条路径回到该顶点，即回路，如果我们不加限制，那么就会发生重复访问的结果。 所以，我们为了避免同一个顶点被重复访问，需要一个机制来记录已访问的顶点，那我们可以很自然的想到利用一个数组来进行记录，我们把它记作标记数组visited，该数组的大小即为顶点的个数，初始状态数组内所有元素均为0，代表还未开始遍历，当顶点iii被访问过时,数组中的元素visited[iii]置为1。 一般而言，在图中有两大类型的遍历：深度优先遍历和广度优先遍历 深度优先遍历 如何理解：深度优先遍历见名知意，就是在图的遍历中，从初始顶点开始，我会不断地往更深处去遍历。假设我们从图中的某个初始点iii 出发,首先访问该初始点,然后选择一个与顶点iii相邻且未被访问过的顶点jjj,再以jjj为初始顶点,从它出发进行深度优先遍历,直到图中所有的顶点全部被访问完。从以上描述我们可以看出深度优先遍历其实是一个递归过程。 例如，上图所示的有向图，我们从顶点1开始进行深度优先遍历，那么访问序列为：1 2 3 4或1 2 4 3 注意：深度优先遍历可能会产生不同的遍历序列，主要是因为我们去选择邻接点时可能存在多个邻接点 ，这就使得深优序列可能不同 上图表示从顶点1开始进行深度优先遍历的过程，可以大致分为以下几步：大家一定要好好理解这个过程 初始顶点为1，访问顶点1，将visited数组对应位置置为1，然后寻到邻接点2 判断顶点2未被访问，递归调用深度优先算法，以2为“起始点”，访问顶点2，将visited数组对应位置置为1，然后寻到邻接点4 判断顶点4未被访问，递归调用深度优先算法，以4为“起始点”，访问顶点4，将visited数组对应位置置为1，然后寻找邻接点 未找到邻接点，退出以顶点4为“起始点”的递归，回到以2为“起始点“的递归，继续寻到邻接点3 判断顶点3未被访问，递归调用深度优先算法，以3为“起始点”,访问顶点3,将visited数组对应位置置为1,然后寻到邻接点2 判断邻接点2已被访问,不再进入递归 顶点3无其他未被访问邻接点,退出以顶点3为“起始点”的递归,回到以2为“起始点”的递归,继续寻找邻接点 顶点2无其他未被访问邻接点,退出以顶点2为“起始点”的递归,回到以1为“起始点”的递归,继续寻找邻接点 顶点1无其他未被访问邻接点,退出以顶点1为“起始点”的递归,程序结束 将上述过程用代码表示: 邻接表表示的图 123456789void DFS(ALGraph* G, int* visited, int index) &#123; printf(&quot;%c &quot;, G-&gt;adjlist[index].info);//打印传入的节点,即访问 visited[index] = 1;//置访问为1 for (EdgeNode* w = G-&gt;adjlist[index].firstEdge; w; w = w-&gt;next) &#123; if (!visited[w-&gt;index]) &#123;//未访问 DFS(G, visited, w-&gt;index); &#125; &#125;&#125; 邻接矩阵表示的图 123456789void DFS(AMGraph* G, int* visited, int index) &#123; printf(&quot;%c &quot;, G-&gt;Vertex[index]);//打印传入的节点,即访问 visited[index] = 1;//置访问为1 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; if (G-&gt;Edge[index][i] != 32767 &amp;&amp; !visited[i]) &#123;//可到达且未访问 DFS(G, visited, i); &#125; &#125;&#125; 可以发现,深度优先算法并不是多么庞杂,但是这个过程涉及到递归,就会不那么容易理解,所以同学一定要踏踏实实地动手模拟这个过程,切忌纸上谈兵 空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|) 时间复杂度： 邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|) 邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(∣V∣2|V|^2∣V∣2) 广度优先遍历 如何理解:广度优先遍历与深度优先遍历是一个相对的概念,所谓广度,也就是说目之所及皆需纳入考虑范围,从初始顶点vvv开始,将其访问,紧接着依次访问顶点vvv 的所有未被访问过的邻接点v1,v2,...,viv_1,v_2,...,v_iv1​,v2​,...,vi​,然后再按照v1,v2,...,viv_1,v_2,...,v_iv1​,v2​,...,vi​的次序访问每一个顶点的所有未访问过的邻接点,以此类推,知道图中所有和初始点vvv有路径相通的顶点都被访问过为止。 上图所示有向图进行广度优先遍历，我们从顶点1开始，最终遍历序列为 1 2 3 4 5 6或1 3 2 4 5 6 注意：广度优先遍历可能会产生不同的遍历序列，主要是因为我们去选择邻接点时可能存在多个邻接点 ，这就使得广优序列可能不同 广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法,需要用到一个队列 代码如下 邻接表存储的图 123456789101112131415161718192021222324void BFS(ALGraph* G, int* visited, int v) &#123;//开始广度遍历 //声明有关队列的函数 Squeue* createQueue(int); bool isEmpty(Squeue*); bool enQueue(Squeue*, int, int); bool deQueue(Squeue*, int*, int); Squeue* sq; sq = createQueue(G-&gt;numV);//创建队列 printf(&quot;%c &quot;, G-&gt;adjlist[v].info);//访问传进来的顶点 enQueue(sq, v, G-&gt;numV);//入队 visited[v] = 1;//置为已访问 while (!isEmpty(sq)) &#123;//队列不空，取出队首元素，进行访问 int top; deQueue(sq, &amp;top, G-&gt;numV); printf(&quot;%c &quot;, G-&gt;adjlist[top].info); for (EdgeNode* w = G-&gt;adjlist[top].firstEdge; w; w = w-&gt;next) &#123;//依次将当前节点的边表入队，和层次遍历一致 if (!visited[w-&gt;index]) &#123; visited[w-&gt;index] = 1; enQueue(sq, w-&gt;index, G-&gt;numV); &#125; &#125; &#125;&#125; 邻接矩阵存储的图 123456789101112131415161718192021222324void BFS(AMGraph* G, int* visited, int v) &#123;//开始广度遍历 //声明有关队列的函数 Squeue* createQueue(int); bool isEmpty(Squeue*); bool enQueue(Squeue*, int, int); bool deQueue(Squeue*, int*, int); Squeue* sq; sq = createQueue(G-&gt;numV);//创建队列 printf(&quot;%c &quot;, G-&gt;Vertex[v]);//访问传进来的顶点 enQueue(sq, v, G-&gt;numV);//入队 visited[v] = 1;//置为已访问 while (!isEmpty(sq)) &#123;//队列不空，取出队首元素，进行访问 int top; deQueue(sq, &amp;top, G-&gt;numV); for (int i = 0; i &lt; G-&gt;numV;i++) &#123; if (G-&gt;Edge[top][i] != 32767 &amp;&amp; !visited[i]) &#123;//可到达且未访问 printf(&quot;%c &quot;,G-&gt;Vertex[i]); visited[i] = 1; enQueue(sq,i,G-&gt;numV); &#125; &#125; &#125;&#125; 空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。 时间复杂度： 1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|) 2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(∣V∣2|V|^2∣V∣2) 图遍历算法的相关应用 图的应用 最小生成树 普利姆（Prlm） ①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。 ②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。 ③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。 ④反复执行②③直到所有所有顶点都加入到生成树中。 概要: 双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2) 而且时间复杂度只和n有关，所以适合稠密图 克鲁斯卡尔（Kruskal） 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。 概要: * * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图 最短路径 迪杰斯特拉 一个源点到其余顶点的最短路径 该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]=1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组： dist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。 path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。 假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&lt;i，j&gt;的权值，若不存在有向边&lt;i，j&gt;，则arcs[i][j]为∞。Dijkstra算法的步骤如下： 1）初始化：集合S初始为{0}，dist[]的初始值dist[i]=arcs[0][i]，i=1，2，…，n-1。 2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]=1。 3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]&lt; dist[k]，则令dist[k]=dist[j] + arcs[j][k]。另外更新path[k]=j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的) 4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。 * 弗洛伊德 * 所有顶点到所有顶点的最短路径 * 算法思想： 递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1) 其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径 * 非带权图 * 两点之间经过边数最少的路径 * 带权图 * 两点之间经过的边上权值之和最小的路径 拓扑排序 AOV 如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex) 拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果： 如果此图全部顶点都被输出了，说明它是不存在回路的AOV网； 如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。 拓扑排序算法： 从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。 关键路径 AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。 第六章：查找 查找的基本概念和顺序查找 查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找 关键字：数据元素中某个可以以唯一标识该元素的数据项 平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值 顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。 1 2 3 4 时间复杂度为O(n) 折半查找 算法思路： 首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。 折半查找分析 折半查找判定树 对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数 时间复杂度为O(logn) 概要: 具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。 分块查找 分块查找又称为索引顺序查找 分块查找思想： ①确定待查找值在哪个块（折半查找） ②在确定的块中查找待查找值（顺序查找） 分块查找分析 由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。 即ASL分块=ASL折半+ASL顺序 二叉排序树 二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树 ①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。 ②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。 ③它的左右子树也是一棵二叉排序树。 算法思想 由于二叉排序树的特点(左子树&lt;根结点&lt;右子树),所以每次查找一个关键字，需要先和根结点进行比较： 如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。 如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。 查找关键字代码 1 2 插入关键字代码 1)空树：直接插入新结点返回成功 2)树不空：检查是否存在关键字重复的结点： ①存在：返回插入失败 ②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树 构造代码 删除结点 ①删除的是叶子结点 方法：直接删去该结点即可 ②删除的是仅有左子树或者右子树的结点 方法：“子承父业” ③删除的是左右子树都有的结点 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子 方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。 二叉排序树分析 查找时间复杂度是O(n) 概要: “左小右大” 平衡二叉树(AVL树) 平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。 平衡因子 定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。 平衡调整 平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。 LL调整(左孩子的左子树上插入结点导致) 最小不平衡子树根结点的平衡因子为2&gt;0 它的左孩子结点平衡因子为1&gt;0 两个都大于0，所以直接右旋就可以调整 概要: “正则右旋” RR调整(右孩子的右子树上插入结点导致) 最小不平衡子树根结点的平衡因子为-2&lt;0 它的右孩子结点平衡因子为-1&lt;0 两个都小于0，所以直接左旋就可以调整 概要: “负则左旋” LR调整(左孩子的右子树上插入结点导致) RL调整(右孩子的左子树上插入结点导致) 概要: 先局部转换为LL或RR，最后进行调整 分析 含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n) 红黑树 B树和B+树 2-3树 2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点 1)2结点包含一个元素和两个孩子(或者没有孩子)。 ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值 ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好) ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。 ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子 3)2-3树所有叶子结点都在同一层次 2-3-4树 2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点 1)2结点包含一个元素和两个孩子(或者没有孩子)。 ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值 ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。 ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。 ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子 3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。 ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子 4)2-3-4树所有叶子结点都在同一层次 B树 B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。 一棵m阶B树或为空树，或为满足如下特性的m叉树： 1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (“两棵子树指针夹着一个关键字”) 2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字) 3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字） 4）所有非叶结点的结构如下： 5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点) 1.B树的查找操作 查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。 ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。 Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。 2.B树的插入操作 分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。 3.B树的删除操作 B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。 1）如果删除的关键字在终端结点上（最底层非叶子结点）： ①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。 ②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。 ③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。 2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点 上的情况来分别考虑对应的方法。 相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。 第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。 第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。 B+树 B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构 m阶的B+树与m阶的B树的主要差异在于： 1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。 2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。 3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。 4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。 散列表 散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。 构造散列函数的tips： 1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。 2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。 3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。 1.常用Hash函数的构造方法： 1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突 2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p 除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性 3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合 4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。 5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。 2.常用Hash函数的冲突处理办法： 1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。 1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。 2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22… 平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。 先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。 1)如果没有，表明该关键字不存在，返回查找失败。 2)如果有，则检查该记录是否等于关键字。 ①如果等于关键字，返回查找成功。 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。 4.散列表的查找性能：和装填因子有关。 * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小 第七章：排序 排序的基本知识 定义：排序就是将原本无序的序列重新排列成有序的序列。 排序的稳定性 如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。 插入类排序 直接插入排序 直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。 时间复杂度为O(n) 直接插入排序是稳定性是稳定的。 折半插入排序 折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。 折半插入排序的时间复杂度为O(n^2) 稳定性：和直接插入排序稳定性相同，是稳定的。 希尔排序 希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。 ①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16…分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。 ②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。 ③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。 概要: 时间复杂度：… 希尔排序的时间复杂度约为O(n^1.3) 在最坏情况下希尔排序的时间复杂度为O(n^2) 空间复杂度：希尔排序的空间复杂度为O(1) 稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。 交换类排序 冒泡排序 假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。 空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1) 时间复杂度 稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。 快速排序 快速排序是一种基于分治法的排序方法。 每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。 1 2 时间复杂度： 最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。 空间复杂度： 由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。 最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn) 最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)； 稳定性：快速排序是不稳定的，是因为存在交换关键字。 选择类排序 简单选择排序 * 空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1) 时间复杂度： 关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次， 对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。 当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2) 稳定性：不稳定 原因就在于交换部分会打破相对顺序 堆排序 什么是堆？ 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。 如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。 如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。 什么是堆排序？ 我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。 时间复杂度： 堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆 堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n) 堆排序不稳定 归并排序 假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。 例如：49 38 65 97 76 13 27 ①首先将整个序列的每个关键字看成一个单独的有序的子序列 ②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象 ③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76} ④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97} 时间复杂度：O(nlog2n) 空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n) 稳定性：稳定 基数排序 基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。 例子：53, 3, 542, 748, 14, 214, 154, 63, 616 补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616 桶实际是一个队列，先进先出(从桶的上面进，下面出) 关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10 空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O® 时间复杂度：需要进行关键字位数d次&quot;分配&quot;和&quot;收集&quot;，一次&quot;分配&quot;需要将n个关键字放进各个队列中，一次&quot;收集&quot;需要将r个桶都收集一遍。所以一次&quot;分配&quot;和一次&quot;收集&quot;时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。 稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。 外部排序 需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。 如何得到初始的归并段 置换选择排序：解决排序段放入内存的问题 如何减少多个归并段的归并次数 最佳归并树：最少的归并次数（I/O次数） 如何每次m路归并快速得到最小的关键字 败者树：减少比较次数 概要: 内存容量无法容纳大量数据 二叉树与树与森林 树与二叉树 如何将一棵树转化成二叉树？ 树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针 将孩子兄弟表示法理解成二叉链表 树转换成二叉树的手动模拟方法： ①将同一结点的各个孩子用线串连起来 ②将每个结点的子树分支，从左往右，除了第一个以外全部删除 概要: 例子 如何将一棵二叉树转化成树？ 二叉树转换成树的手动模拟方法： ①将二叉树从上到下分层，并调节成水平方向。 (分层方法：每遇到左孩子则为一层) ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。 例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a. ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。 概要: 例子 森林与二叉树 森林：森林是m（m≥0）棵互不相交的树的集合 如何将森林转换成二叉树？ 森林转换成树的手动模拟方法： ①将森林中每棵树都转换成二叉树 ②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树…依次类推 概要: 例子 如何将二叉树转换成森林？ 二叉树转换成森林的手动模拟方法： 反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。 概要: 例子 树与森林的遍历 先序：先访问根结点，再访问根结点的每棵子树。 访问子树也是按照先序的要求 后序：先访问根结点的每棵子树，再访问根结点。 访问子树也是按照先序的要求 树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历 概要: 例子","categories":[{"name":"讲义","slug":"讲义","permalink":"http://lhyhyl.github.io/categories/%E8%AE%B2%E4%B9%89/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"邻接矩阵的构造","slug":"数据结构百题狂练/图/使用邻接矩阵存储图","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/图/使用邻接矩阵存储图/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E5%9B%BE/%E4%BD%BF%E7%94%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%9B%BE/","excerpt":"","text":"使用邻接矩阵构造图 分析： 其实图相比于其它数据结构较复杂，但也是十分易懂的，对于使用邻接矩阵存储的图来说，我们所需要知道的数据有 图的定点数、边数、用一个二维数组存储的边与边的联系及其权值，未连接的边我们要使用无穷表示，节点自身用 0 表示，初始时除自身节点外均表示为无穷。另外我们还需要一个一维数组用来存储我们的顶点个数 代码如下：读者可以自行测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define MAXSIZE 100 //数组最大值typedef struct Graph &#123; char Vertex[MAXSIZE]; int Edge[MAXSIZE][MAXSIZE]; int numV, numE;//顶点、边数量&#125;adjMatrix;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt; void createGraph(adjMatrix *G) &#123; int v, e,vi,vj,w; printf(&quot;请输入创建的图的顶点与边个数（以空格分开）：&quot;); scanf(&quot;%d %d&quot;,&amp;v,&amp;e); G-&gt;numE = e; G-&gt;numV = v; //初始化图 for (int i = 0; i &lt; v;i++) &#123; for (int j = 0; j &lt; v;j++) &#123; i == j ? G-&gt;Edge[i][j] = 0 : G-&gt;Edge[i][j] = 32767; &#125; &#125; //将顶点存入数组 for (int i = 0; i &lt; G-&gt;numV;i++) &#123; printf(&quot;请输入第%d个节点信息：&quot;,i+1); getchar(); scanf(&quot;%c&quot;,&amp;G-&gt;Vertex[i]); &#125; //开始建立边与边的关系 for (int i = 0; i &lt; G-&gt;numE;i++) &#123; printf(&quot;请输入边的信息vi vj w(以空格分开)&quot;); scanf(&quot;%d %d %d&quot;,&amp;vi,&amp;vj,&amp;w);//有权值就写 G-&gt;Edge[vi - 1][vj - 1] = w;//① G-&gt;Edge[vj - 1][vi - 1] = w;//② 这代表无向图 &#125; &#125;void dispGraph(adjMatrix *G) &#123; int i, j; printf(&quot;\\n输出顶点的信息（字符）:\\n&quot;); for (i = 0; i &lt; G-&gt;numV; i++) printf(&quot;%8c&quot;, G-&gt;Vertex[i]); printf(&quot;\\n输出邻接矩阵:\\n&quot;); printf(&quot;\\t&quot;); for (i = 0; i &lt; G-&gt;numV; i++) printf(&quot;%8c&quot;, G-&gt;Vertex[i]); for (i = 0; i &lt; G-&gt;numV; i++) &#123; printf(&quot;\\n%8c&quot;, G-&gt;Vertex[i]); for (j = 0; j &lt; G-&gt;numV; j++) &#123; if (G-&gt;Edge[i][j] == 32767) //两点之间无连接时权值为默认的32767， //在无向图中一般用&quot;0&quot;表示，在有向图中一般用&quot;∞&quot;, //这里为了方便统一输出 &quot;∞&quot; printf(&quot;%8s&quot;, &quot;∞&quot;); else printf(&quot;%8d&quot;, G-&gt;Edge[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125;//int main() &#123;// adjMatrix G;// createGraph(&amp;G);// dispGraph(&amp;G);//&#125; 运行截图：","categories":[{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/categories/%E5%9B%BE/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/tags/%E5%9B%BE/"}]},{"title":"广度优先遍历","slug":"数据结构百题狂练/图/广度优先遍历","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/图/广度优先遍历/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E5%9B%BE/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/","excerpt":"","text":"题目：对采用邻接表存储的图进行广度优先遍历 分析：我们知道邻接表上的顶点所连接的节点都是它的相邻节点，而对于广度优先遍历来说，类似于层次遍历，就是要把所有的邻接点进行访问， 所以我们需要从第一个节点开始访问它的所有邻接点，还有需要注意的是，当我们把邻接点访问后，需要依次访问邻接点的邻接点，这就需要 用队列将我们访问过得邻接点入队，这和层次遍历一样，也只有这样，我们才能访问所有的节点。当然，在这个过程中，会有重复访问的情况， 所以我们需要用一个数组来记录节点的访问情况，已访问置 true 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#define MAXSIZE 100#define TYPE int//边表结构 struct EdgeNode &#123; int index;//在数组中的下标 int weight;//权值 EdgeNode *next;//下一个邻接点&#125;;//顶点表节点结构typedef struct VertexNode &#123; int info;//节点信息 EdgeNode *firstNode;//第一个邻接节点&#125;Adjlist[MAXSIZE]; //图结构struct ALGraph &#123; Adjlist adjlist;//顶点数组 int numE, numV;//边数，顶点数&#125;; //队列结构(我们采用顺序队列)struct Squeue &#123; TYPE *arr; int front, rear;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void BFS(ALGraph *G) &#123;//开始广度遍历 //声明有关队列的函数 Squeue *createQueue(int); bool isEmpty(Squeue *); bool enQueue(Squeue *, TYPE, int); bool deQueue(Squeue *sq, TYPE *data, int maxSize); //设置一个标志数组，用于标志节点是否被访问 初始化0,1代表已访问 int *visited = (int *)malloc(sizeof(int)*G-&gt;numV); for (int i = 0; i &lt; G-&gt;numV; i++) &#123; visited[i] = 0; &#125; Squeue *sq; sq = createQueue(G-&gt;numV);//创建队列 //从第一个节点开始遍历 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; if (!visited[i]) &#123;//如果没有被访问，便进行访问 printf(&quot;%c &quot;, G-&gt;adjlist[i]);//我们这里进行简单的打印代表访问 visited[i] = 1;//置为已访问 enQueue(sq, G-&gt;adjlist[G-&gt;numV].info, G-&gt;numV);//入队 while (!isEmpty(sq)) &#123;//队列不空，取出队首元素，进行访问 TYPE top; deQueue(sq, &amp;top, G-&gt;numV); if (!visited[top]) &#123; visited[top] = 1; printf(&quot;%c &quot;, G-&gt;adjlist[top]); for (EdgeNode *w = G-&gt;adjlist[top].firstNode; w; w = w-&gt;next) &#123;//依次将当前节点的边表入队，和层次遍历一致 if (!visited[w-&gt;index]) enQueue(sq, w-&gt;index, G-&gt;numV); &#125; &#125; &#125; &#125; &#125; &#125;int main() &#123; ALGraph *graph = (ALGraph *)malloc(sizeof(ALGraph *)); //声明函数 void createGraph(ALGraph *); void dispGraph(ALGraph *); //创建图 createGraph(graph); //打印图 dispGraph(graph); //广度优先遍历 BFS(graph); return 0; 运行结果如下： 你不对自己狠一点儿，真的只能沦落为炮灰。拼命的时候一定不要对自己手下留情，你只有努力，才配得上更好的生活！","categories":[{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/categories/%E5%9B%BE/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/tags/%E5%9B%BE/"}]},{"title":"深优广优判断vi到vj是否存在路径","slug":"数据结构百题狂练/图/深优广优判断vi到vj是否存在路径","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/图/深优广优判断vi到vj是否存在路径/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E5%9B%BE/%E6%B7%B1%E4%BC%98%E5%B9%BF%E4%BC%98%E5%88%A4%E6%96%ADvi%E5%88%B0vj%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/","excerpt":"","text":"分析： 采用深度优先：我们从 vi 顶点开始进行深度遍历，若存在路径则必然可以走到 vj 顶点处； 采用广度优先：同样从 vi 顶点开始进行广度遍历，若存在则必然可以走到 vj 顶点处。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#define _CRT_SECURE_NO_WARNINGS#define MAXSIZE 100#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct EdgeNode &#123;//边表结点 int index;//该边所指向的顶点的位置 int weight;//权值 EdgeNode *next;//下一个邻接边&#125;EdgeNode; typedef struct VertexNode &#123;//顶点表节点 char info;//顶点信息 EdgeNode *firstEdge;//指向第一条依附该顶点的边的指针&#125;VertexNode, Adjlist[MAXSIZE]; typedef struct &#123; Adjlist adjlist;//顶点数组 int numE, numV;//边数、顶点数&#125;ALGraph;//链队struct Link &#123; int node;//我们进行广度优先时会用到，将顶点序号入队 struct Link *next;&#125;;struct LinkQueue &#123; struct Link *front, *rear;&#125;; void DFS(ALGraph *G, int vi, int vj, int *visited, int &amp;flag) &#123; for (EdgeNode *p = G-&gt;adjlist[vi].firstEdge; p; p = p-&gt;next) &#123; if (!visited[p-&gt;index]) &#123; visited[p-&gt;index] = 1; if (p-&gt;index == vj) &#123; flag = 1; &#125; DFS(G, p-&gt;index, vj, visited, flag); &#125; &#125; &#125;bool judgeRouteInDFS(ALGraph *G, int vi, int vj) &#123;//传入图G，路线端点vi vj int *visited = (int *)malloc(sizeof(int)*G-&gt;numV); int flag = 0;//进入递归，路径存在标志 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; visited[i] = 0;//初始化 &#125; if (!visited[vi]) &#123; visited[vi] = 1; DFS(G, vi, vj, visited, flag); &#125; if (flag) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; bool judgeRouteInBFS(ALGraph *G, int vi, int vj) &#123; int *visited = (int *)malloc(sizeof(int)*G-&gt;numV); int flag = 0;//进入递归，路径存在标志 int index;//进行判断用 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; visited[i] = 0;//初始化 &#125; bool isEmpty(LinkQueue *lq); bool enQueue(LinkQueue *, int); bool deQueue(LinkQueue *, int*); LinkQueue *create();//声明创建队列的方法。广度优先遍历需要用到队列 LinkQueue *lq; lq = create(); if (!visited[vi]) &#123; visited[vi] = 1; enQueue(lq, vi);//入队 &#125; while (!isEmpty(lq)) &#123;//当队列不空，取出队首元素进行判断 deQueue(lq, &amp;index); if (!visited[index]) &#123;//若未曾访问过，进行判断 visited[index] = 1; if (vj == index) &#123; flag = 1; &#125; &#125; for (EdgeNode *p = G-&gt;adjlist[index].firstEdge; p; p = p-&gt;next) &#123; if (!visited[p-&gt;index]) &#123; enQueue(lq, p-&gt;index);//把所有的未访问过得邻接顶点入队 &#125; &#125; &#125; if (flag) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;int main() &#123; int haveRoute; void createGraphInFile(ALGraph *G); ALGraph *G = (ALGraph *)malloc(sizeof(ALGraph *)); createGraphInFile(G);//创建图 int vi, vj; printf(&quot;请输入vi，vj\\n&quot;); printf(&quot;vi= &quot;); scanf(&quot;%d&quot;, &amp;vi); printf(&quot;vj= &quot;); scanf(&quot;%d&quot;, &amp;vj); while (vi &gt;= G-&gt;numV || vj &gt;= G-&gt;numV) &#123; printf(&quot;输入有误，不存在该顶点，请重新输入！&quot;); printf(&quot;vi= &quot;); scanf(&quot;%d&quot;, &amp;vi); printf(&quot;vj= &quot;); scanf(&quot;%d&quot;, &amp;vj); &#125; haveRoute = judgeRouteInBFS(G, vi - 1, vj - 1); if (haveRoute) &#123; printf(&quot;顶点%d到顶点%d存在路径&quot;, vi, vj); &#125; else &#123; printf(&quot;%d到%d不存在路径&quot;, vi, vj); &#125; return 0;&#125;","categories":[{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/categories/%E5%9B%BE/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/tags/%E5%9B%BE/"}]},{"title":"邻接表的构造","slug":"数据结构百题狂练/图/邻接表存储图☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/图/邻接表存储图☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E5%9B%BE/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E5%9B%BE%E2%98%86/","excerpt":"","text":"采用邻接表的方式存储图 分析： 采用邻接表相对于邻接矩阵来说更节省存储空间，这里我们需要两个数据结构： ①顶点表结构：包括顶点信息及指向第一个邻接点的头指针 ②边表结构：包括该邻接点域（在数组中的下标）、权值及下一个邻接点指针 ③一个数组，用于存储所有顶点，因为数组的随机存储特性，方便我们查找 ④图结构：包括顶点数组及顶点数、边数 具体创建流程： 首先我们需要输入图的顶点数和边数，将其存入图结构中，并由输入的顶点数依次输入顶点信息，并将第一个邻接点的头指针 置位 NULL，这是建立顶点表的流程； 其次我们需要建立边表，根据输入的边个数，依次输入边（vi，vj）的顶点序号，再采取头插法进行插入，若是无向图则需要 重复反向依次设置，至此，图的邻接表结构建立完成。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define _CRT_SECURE_NO_WARNINGS#define MAXSIZE 100typedef struct EdgeNode &#123;//边表结点 int index;//邻接点在数组中的下标 int weight;//权值 EdgeNode *next;//下一个邻接点&#125;EdgeNode; typedef struct VertexNode &#123;//顶点表节点 char info;//顶点信息 EdgeNode *firstNode;//顶点的第一个邻接点指针&#125;VertexNode, Adjlist[MAXSIZE]; typedef struct &#123; Adjlist adjlist;//顶点数组 int numE, numV;//边数、顶点数&#125;ALGraph; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; void createGraph(ALGraph *G) &#123; int e, v, vi, vj, w; printf(&quot;请输入图的边数与结点数（以空格分开）：&quot;); scanf(&quot;%d %d&quot;, &amp;e, &amp;v); G-&gt;numE = e; G-&gt;numV = v; printf(&quot;请依次输入顶点信息：\\n&quot;); for (int i = 0; i &lt; G-&gt;numV; i++) &#123; printf(&quot;请输入第%d个结点信息：&quot;, i + 1); getchar(); scanf(&quot;%c&quot;, &amp;G-&gt;adjlist[i].info); G-&gt;adjlist[i].firstNode = NULL; &#125; printf(&quot;请输入边表信息：\\n&quot;); for (int i = 0; i &lt; G-&gt;numE; i++) &#123; printf(&quot;请输入边（vi，vj）的顶点序号及其权值（以空格分开）：&quot;); scanf(&quot;%d %d %d&quot;, &amp;vi, &amp;vj, &amp;w); //若是无向图则需要两个顶点进行操作,采用头插法 EdgeNode *e = (EdgeNode *)malloc(sizeof(EdgeNode *)); e-&gt;index = vj - 1;//数组下标要减一 e-&gt;weight = w; e-&gt;next = G-&gt;adjlist[vi - 1].firstNode; G-&gt;adjlist[vi - 1].firstNode = e; EdgeNode *ed = (EdgeNode *)malloc(sizeof(EdgeNode *)); ed-&gt;index = vi - 1; ed-&gt;weight = w; ed-&gt;next = G-&gt;adjlist[vj - 1].firstNode; G-&gt;adjlist[vj - 1].firstNode = ed; &#125; &#125;void dispGraph(ALGraph *G) &#123;//将图用邻接表的形式展示出来 for (int i = 0; i &lt; G-&gt;numV; i++) &#123; int j = i; printf(&quot;%c--&gt;&quot;, G-&gt;adjlist[j].info); EdgeNode *p = G-&gt;adjlist[j].firstNode; while (p) &#123; printf(&quot;(%d)%c--&gt;&quot;, p-&gt;weight, G-&gt;adjlist[p-&gt;index].info); p = p-&gt;next; &#125; printf(&quot;^\\n&quot;); &#125; &#125;int main() &#123; ALGraph G; createGraph(&amp;G); dispGraph(&amp;G); return 0;&#125; 运行结果如图：","categories":[{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/categories/%E5%9B%BE/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/tags/%E5%9B%BE/"}]},{"title":"创建循环队列","slug":"数据结构百题狂练/栈和队列/创建循环顺序队列","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/创建循环顺序队列/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%88%9B%E5%BB%BA%E5%BE%AA%E7%8E%AF%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/","excerpt":"","text":"此文件用于创建一个顺序队列，出队，入队, 判断队空，判断队满等操作 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TYPE int struct Squeue &#123; TYPE *arr; TYPE front, rear;&#125;; //创建队列Squeue *create(int n) &#123; struct Squeue *sq = (struct Squeue *)malloc(sizeof(struct Squeue)); sq-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*n);//数组大小 sq-&gt;front = 0; sq-&gt;rear = 0; return sq;&#125;//判断队满(这里采用牺牲一个存储单元来实现,约定队头指针在队尾指针的下一个位置作为队满的标志)bool isFull(Squeue *sq,int maxSize) &#123; return (sq-&gt;rear + 1) % maxSize == sq-&gt;front;&#125;//判断队空bool isEmpty(Squeue *sq) &#123; return sq-&gt;front == sq-&gt;rear;&#125;//判断队列中元素个数int count(Squeue *sq,int maxSize) &#123; return (sq-&gt;rear - sq-&gt;front + maxSize) % maxSize;&#125;//入队bool enQueue(Squeue *sq,int data,int maxSize) &#123; if (isFull(sq,maxSize)) return false; sq-&gt;arr[sq-&gt;rear] = data; sq-&gt;rear = (sq-&gt;rear + 1) % maxSize; return true;&#125;//出队bool deQueue(Squeue *sq,int &amp;data,int maxSize) &#123; if (isEmpty(sq)) return false; data = sq-&gt;arr[sq-&gt;front]; sq-&gt;front = (sq-&gt;front + 1) % maxSize; return true;&#125; 人生最重要的不是努力，不是奋斗，而是抉择。","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"将队列中元素逆置","slug":"数据结构百题狂练/栈和队列/利用栈和队列将队列中的元素逆置☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/利用栈和队列将队列中的元素逆置☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%88%A9%E7%94%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%B0%86%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E9%80%86%E7%BD%AE%E2%98%86/","excerpt":"","text":"题目：有一个队列和一个栈，设计一个算法是队列中的元素逆置。 分析： 我们可以一次取出队列中的元素放到栈中，然后在依次取出入队。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct Stack&#123; int* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;;struct Squeue &#123;//这里我才用的是循环队列，也可以不用循环队列 int *arr; int front, rear;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; struct Squeue *sq; struct Stack *s; int n,data; Squeue *createQueue(int ); bool enQueue(Squeue *,int,int); bool deQueue(Squeue *,int *,int); void printQ(Squeue *, int ); Stack *createStack(int ); bool push(Stack *,int ); bool pop(Stack *); int *top(Stack *); printf(&quot;请输入队列及栈大小:&quot;); scanf(&quot;%d&quot;,&amp;n); sq = createQueue(n+1);//因为是循环队列，需要留一个空间作为满空判定 s = createStack(n); for (int i = 0; i &lt; n;i++) &#123; printf(&quot;请输入第%d个入队元素：&quot;,i+1); scanf(&quot;%d&quot;,&amp;data); enQueue(sq,data, n + 1);//入队 &#125; printf(&quot;原队列中元素为：&quot;); printQ(sq,n+1); printf(&quot;\\n&quot;); for (int i = 0; i &lt; n;i++) &#123; deQueue(sq,&amp;data, n + 1);//出队 push(s,data);//入栈 &#125; for (int i = 0; i &lt; n; i++) &#123; data = *top(s); pop(s);//出栈 enQueue(sq,data, n + 1);//入队 &#125; printf(&quot;逆转后队列中元素为：&quot;); printQ(sq, n + 1); &#125; 队列相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TYPE int struct Squeue &#123; TYPE *arr; TYPE front, rear;&#125;; //创建队列Squeue *createQueue(int n) &#123; struct Squeue *sq = (struct Squeue *)malloc(sizeof(struct Squeue)); sq-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*n);//数组大小 sq-&gt;front = 0; sq-&gt;rear = 0; return sq;&#125;//判断队满(这里采用牺牲一个存储单元来实现,约定队头指针在队尾指针的下一个位置作为队满的标志)bool isFull(Squeue *sq,int maxSize) &#123; return (sq-&gt;rear + 1) % maxSize == sq-&gt;front;&#125;//判断队空bool isEmpty(Squeue *sq) &#123; return sq-&gt;front == sq-&gt;rear;&#125;//判断队列中元素个数int count(Squeue *sq,int maxSize) &#123; return (sq-&gt;rear - sq-&gt;front + maxSize) % maxSize;&#125;//入队bool enQueue(Squeue *sq,int data,int maxSize) &#123; if (isFull(sq,maxSize)) return false; sq-&gt;arr[sq-&gt;rear] = data; sq-&gt;rear = (sq-&gt;rear + 1) % maxSize; return true;&#125;//出队bool deQueue(Squeue *sq, int *data,int maxSize) &#123;//data我最开始用的&amp;data会报错， if (isEmpty(sq)) return false; *data = sq-&gt;arr[sq-&gt;front]; sq-&gt;front = (sq-&gt;front + 1) % maxSize; return true;&#125;//打印队列中元素void printQ(Squeue *sq,int maxSize) &#123; if (isEmpty(sq)) return ; int np = sq-&gt;front; while (np!=sq-&gt;rear) &#123; printf(&quot;%d &quot;,sq-&gt;arr[np]); np = (np + 1) % maxSize; &#125;&#125; 当我真心在追寻著我的梦想时，每一天都是缤纷的，因为我知道每一个小时，都是在实现梦想的一部分。","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"创建栈","slug":"数据结构百题狂练/栈和队列/创建栈","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/创建栈/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%88%9B%E5%BB%BA%E6%A0%88/","excerpt":"","text":"该文件用于创建栈，及其相关操作 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define TYPE char struct Stack&#123; TYPE* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;; /* --------------以下为实现函数--------------------*///创建一个栈Stack *createStack(int size) &#123; struct Stack *stack = (struct Stack*)malloc(sizeof(struct Stack));//给栈分配空间 stack-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*size);//给内存首地址分配空间，大小用户指定 stack-&gt;len = size;//栈容量 stack-&gt;top = -1;//栈顶下标，当前无元素，故为-1 return stack;&#125;//判断栈满bool full(Stack *stack) &#123; return stack-&gt;top + 1 &gt;= stack-&gt;len;&#125;//判断栈空bool empty(Stack *stack) &#123; return stack-&gt;top == -1;&#125;//入栈bool push(Stack *stack,TYPE data) &#123; if (full(stack)) return false; *(stack-&gt;arr + ++stack-&gt;top) = data; return true;&#125;//出栈bool pop(Stack *stack) &#123; if (empty(stack)) return false; stack-&gt;top--; return true; &#125;//查看栈顶元素TYPE *top(Stack *stack) &#123; if (empty(stack)) return NULL; return stack-&gt;arr + stack-&gt;top;&#125; //销毁void destory(Stack *stack) &#123; free(stack-&gt;arr); free(stack); &#125;","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"递归函数的非递归计算","slug":"数据结构百题狂练/栈和队列/利用栈实现递归函数的非递归计算","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/利用栈实现递归函数的非递归计算/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97/","excerpt":"","text":"题目：利用栈实现以下递归函数的非递归计算 分析： 这里我们需要使用栈的先进后出特性。我们可以看出，从 n=2 开始，每一个值便都与前两个值挂钩，且式子不变，我们可以从栈顶到栈底依次边出栈边计算，直至栈底，便可以得出最终结果。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Recursion &#123; int no; int val;&#125;;struct Stack &#123; Recursion *arr; int len; int top;&#125;;int getP(Stack *s,int n,int x) &#123;//该算法函数,传入栈，n和x if (n==0) &#123; return 1; &#125; int fv1 = 1, fv2 = 2 * x; for (int i = n; i &gt;= 2;i--) &#123;//将序号入栈，从上至下，从2到n s-&gt;top++; s-&gt;arr[s-&gt;top].no = i; &#125; while (s-&gt;top&gt;=0) &#123;//边出栈边计算 s-&gt;arr[s-&gt;top].val = 2 * x*fv2 - 2 * (s-&gt;arr[s-&gt;top].no - 1)*fv1; fv1 = fv2; fv2 = s-&gt;arr[s-&gt;top].val; s-&gt;top--; &#125; return fv2;&#125;int main() &#123; Stack *s; //声明各类方法 Stack *createStack(int); bool pushS(Stack *,Recursion *); bool full(Stack *); bool empty(Stack *); bool top(Stack *); bool pop(Stack *); int n, x;//题目所要用到的n和x int p;//用于接收结果 printf(&quot;请输入n和x: \\n&quot;); printf(&quot;n=&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;x=&quot;); scanf(&quot;%d&quot;, &amp;x); //创建大小为n的栈 s = createStack(n); p=getP(s,n,x); printf(&quot;%d&quot;,p); return 0;&#125; 只有尝试过，努力过，坚持过，才能有收获。一分耕耘，一分收获，只有努力了，才能绽放出成功的花朵。只要功夫深，铁杵磨成针。我相信，只要我朝着这个理想努力奋斗，坚持不懈，那么，我就一定会成功！","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"括号匹配","slug":"数据结构百题狂练/栈和队列/括号匹配（利用队列和栈）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/括号匹配（利用队列和栈）/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%EF%BC%88%E5%88%A9%E7%94%A8%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%EF%BC%89/","excerpt":"","text":"题目：假设一个算法表达式包含圆括号、方括号、和花括号 3 种类型的括号，编写一个算法来判断表达式里的括号是否配对 分析： 我们利用队列来存储算术表达式，再利用一个栈来进行判定，具体流程为：依次从队列中取出表达式，如果是左括号则入栈， 如果是右括号则取出栈顶元素，比对是否配对，如果不匹配，终止，匹配则继续。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct LinkQueue &#123; struct Link *front, *rear;&#125;;struct Stack&#123; char* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;bool matchBracket(LinkQueue *lq, Stack *s) &#123; char letterQ, *letterS; bool isEmpty(LinkQueue *); bool deQueue(LinkQueue *, char *); bool push(Stack *, char); char *top(Stack *); bool pop(Stack *); bool empty(Stack *); while (!isEmpty(lq)) &#123;//如果队列不空 deQueue(lq, &amp;letterQ);//取出队首元素 if (letterQ == &#x27;(&#x27; || letterQ == &#x27;&#123;&#x27; || letterQ == &#x27;[&#x27;) &#123;//如果是左括号，入栈 push(s, letterQ); &#125; else &#123;//如果是右括号，取出栈顶元素对比 if (empty(s)) &#123; return false; &#125; letterS = top(s); pop(s); switch (letterQ) &#123; case &#x27;)&#x27;: if (*letterS != &#x27;(&#x27;)return false; break; case &#x27;]&#x27;: if (*letterS != &#x27;[&#x27; ) return false; break; case &#x27;&#125;&#x27;: if (*letterS != &#x27;&#123;&#x27; ) return false; break; default:break; &#125; &#125; &#125; if (empty(s)) &#123; return true; &#125; else &#123; return false; &#125;&#125;int main() &#123; int n; char letter; struct LinkQueue *lq; struct Stack *s; LinkQueue *create(); bool enQueue(LinkQueue *, char); void printQ(LinkQueue *); Stack *createStack(int); lq = create(); printf(&quot;请输入栈的大小：n=&quot;); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;\\n%c&quot;, &amp;letter);//这里注意需要在%c前面加上回车符，这样就不会将回车也作为一个字符获取了 enQueue(lq, letter); &#125; printQ(lq); printf(&quot;\\n&quot;); s = createStack(n); if (matchBracket(lq, s)) &#123; printf(&quot;该算术表达式配对&quot;); &#125; else &#123; printf(&quot;该算术表达式不配对&quot;); &#125; return 0;&#125; 队列和栈的相关代码请移步链式队列 栈 通往成功的道路上有一门必修课叫孤独。","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"车厢调度","slug":"数据结构百题狂练/栈和队列/车厢调度","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/车厢调度/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E8%BD%A6%E5%8E%A2%E8%B0%83%E5%BA%A6/","excerpt":"","text":"题目：利用栈进行车厢调度，使软座全部位于硬座前面 分析： 原文题目较长，但仔细分析后，这道题是一类较为简单的题。这里其实也并不需要用到栈的先入后出的特性，仅仅需要将硬座暂存，让软座先出去而已，所以将栈换成其他结构也是可以的，只要能够暂存数据。但这里题目要求用栈。 为了模拟列车座位，我们采用两个数组来存储，数组 A 为入口处火车，数组 B 为出口处火车，A 内数据依次入栈，若为硬座则压入栈，若为软座则直接进入 B，最后栈内元素全部出栈，入 B，至此，完成要求。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Stack &#123; char *arr; int len; int top;&#125;;void trainArrange(char *arrA,char *arrB,Stack *s) &#123;//传入入口车厢，出口车厢，栈 int i = 0, j = 0; char *c;//接收出栈硬座 bool push(Stack *,char ); char *top(Stack *); bool pop(Stack *); bool empty(Stack *); while (i&lt;10) &#123; if (arrA[i]==&#x27;H&#x27;) &#123;//硬座，入栈 push(s,arrA[i]); &#125; else &#123;//软座，入B arrB[j++] = arrA[i]; &#125; i++; &#125; while (!empty(s)) &#123;//若栈中还有硬座，全部入B c = top(s); pop(s); arrB[j++] = *c; &#125; &#125;int main() &#123; char arrA[10] = &#123;&#x27;H&#x27;,&#x27;S&#x27;,&#x27;S&#x27;,&#x27;H&#x27;,&#x27;H&#x27;,&#x27;S&#x27;,&#x27;S&#x27;,&#x27;S&#x27;,&#x27;H&#x27;,&#x27;H&#x27; &#125;;//用H代表硬座，S代表软座 char arrB[10] = &#123; 0 &#125;;//B数组初始为空 Stack *createStack(int); Stack *s; s = createStack(10);//创建栈 trainArrange(arrA,arrB,s); for (int i = 0; i &lt; 10;i++) &#123;//打印重排后的车厢 printf(&quot;%c&quot;,arrB[i]); &#125; return 0;&#125; 无论你觉得自己多么的了不起，也永远有人比你更强；无论你觉得自己多么的不幸，永远有人比你更加不幸。","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"车辆轮渡管理","slug":"数据结构百题狂练/栈和队列/车辆轮渡管理","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/车辆轮渡管理/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E8%BD%A6%E8%BE%86%E8%BD%AE%E6%B8%A1%E7%AE%A1%E7%90%86/","excerpt":"","text":"题目：汽车轮渡，要求：每次 10 辆，客车优先于货车，每上 4 辆客车才能上 1 辆货车，客车不足 4 辆时，货车代替货车不足时，允许客车都上。 分析：这仍然是一类排序的问题，王道书上的解答可以，核心意思就是客车和货车分为两个队列，客车队列出 4 辆，紧接着货车 队列出一辆；当出现客车不足时，出货车队列代替，当货车不足时，继续出客车队列。代码也不难实现。 这里我想分享一下自己的想法，我们上一题做过货车车厢调整的算法，利用栈将软座调整到硬座的前面，这里我们可以仿造相当于我们要将客车调整到货车的前面，只是有限制，每 4 辆客车就需要插入一辆货车，而面对特殊情况，我们也可以很好地处理，直接将剩余车辆（无论客车还是货车）直接连接到队列后面。之后我们从队列中取 10 辆车即可 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt; struct Stack &#123; int *arr; int len; int top;&#125;;void manageCar(int *arrCar,int *arrArrange,Stack *s) &#123; int i = 0, passengerCar = 0,j=0; int *c;//接收出栈硬座 bool push(Stack *, int); int *top(Stack *); bool pop(Stack *); bool empty(Stack *); for (; arrCar[i] == 1 || arrCar[i] == 2;i++) &#123; if (arrCar[i]==2&amp;&amp;passengerCar&lt;4) &#123;//如果是货车且之前还没有4辆客车，入栈 push(s,arrCar[i]); &#125; else &#123;//若是客车，直接入arrArrange if (passengerCar==4) &#123;//若之前已有连续4辆客车，出栈入货车 c=top(s); pop(s); arrArrange[j++] = *c; passengerCar = 0;//重新计数 &#125; arrArrange[j++] = arrCar[i]; passengerCar++;//连续客车数加一 &#125; &#125; while(!empty(s)) &#123;//栈内元素不空，加入到arrArrange c = top(s); pop(s); arrArrange[j++] = *c; &#125;&#125;int main() &#123; int arrCar[] = &#123; 2,1,2,1,1,1,1,2,2,2,1,1 &#125;;//我们用1代表客车，用2发表货车,arrCar代表当前的车序列，然后我们需要重排 int arrArrange[20] = &#123; 0 &#125;;//初始化为0，接收重排的车队 Stack *createStack(int); Stack *s; s = createStack(20);//创建一个栈 manageCar(arrCar,arrArrange,s); for (int i = 0; i &lt; 10;i++) &#123;//取10辆车出来 printf(&quot;%d &quot;,*(arrArrange+i)); &#125; return 0;&#125; 运行结果： 人生，并非姹紫嫣红才算春天，有时，素心淡雅也是一种恒久的芬芳。若有一天，在清风明月间，推开一扇斑驳的门扉，看韶华渐远，还能轻拥经历，怀抱暖香，回看到一个简单的自己，便是时光深处最美的懂得。","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"创建链队","slug":"数据结构百题狂练/栈和队列/链式队列","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/栈和队列/链式队列/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/","excerpt":"","text":"此文件用于创建一个链式队列 分析： 我们需要创建一个链表，然后设置 front、rear 指针，用来模拟入队出队的过程 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Link &#123; int data; struct Link *next;&#125;;struct LinkQueue &#123; struct Link *front, *rear;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //创建链队LinkQueue *create() &#123; struct Link *h,*p; struct LinkQueue *lq; Link *createLink(int); h = createLink(0); p = h-&gt;next; lq-&gt;front = h; while (p-&gt;next) &#123; p = p-&gt;next; &#125; lq-&gt;rear-&gt;next = p; return lq;&#125;//判断空bool isEmpty(LinkQueue *lq) &#123; return lq-&gt;front == lq-&gt;rear;&#125;//入队bool enQueue(LinkQueue *lq,int data) &#123;//队尾插入 struct Link *newd = (struct Link *)malloc(sizeof(struct Link)); newd-&gt;data = data; lq-&gt;rear-&gt;next = newd; lq-&gt;rear = newd; return true;&#125;//出队bool deQueue(LinkQueue *lq,int *data) &#123; if (isEmpty(lq))return false; struct Link *p = lq-&gt;front-&gt;next;//保存下一个节点 *data = lq-&gt;front-&gt;next-&gt;data;//取出队首节点值 lq-&gt;front-&gt;next = p-&gt;next;//删除队首节点 if (lq-&gt;rear==p) &#123; lq-&gt;rear = lq-&gt;front; &#125; free(p); return true;&#125; 苦难，是化了妆的祝福。","categories":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"两个链表取相等元素","slug":"数据结构百题狂练/链表/两链表取相同元素","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/两链表取相同元素/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E9%93%BE%E8%A1%A8%E5%8F%96%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：设 A、B 是两个单链表（带头结点），其中元素递增有序，设计一个算法从 A、B 中的公共元素产生单链表 C，要求不破坏 A、B 节点 分析： 要求不破坏 A、B 节点，故我们需要重新创建分配节点空间，来进行连接。为寻找公共元素，每遍历 A 中的一个元素，都去 与 B 中元素一一比较，同则取值给另一空间节点，连接到 C 上。时间复杂度为 O(n^2)。 因为这两个链表是递增有序的，那么我们可以设置两个指针同步比较，相同则加入 c，不同小的那个往后移，直至到链表末尾 这样的时间复杂度为 O(n). 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Link &#123; int data; struct Link *next;&#125;;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void linkCommon(Link *a, Link *b, Link *c ) &#123; struct Link *lc = c,*la=a-&gt;next,*lb=b-&gt;next,*rc=lc; while (la) &#123; while (lb) &#123; if (la-&gt;data==lb-&gt;data) &#123;//如果是公共元素 struct Link *p = (struct Link*)malloc(sizeof(struct Link)); p-&gt;data = la-&gt;data; rc-&gt;next = p;//采用尾插法 rc = p; break; &#125; lb = lb-&gt;next; &#125; la = la-&gt;next; lb = b-&gt;next; &#125; rc-&gt;next = NULL;//最后一个节点指针需要指向NULL。&#125;void listCommon(Link *a,Link *b,Link *c) &#123; struct Link *rc = c, *la = a-&gt;next, *lb = b-&gt;next; while (la&amp;&amp;lb) &#123; if (la-&gt;data==lb-&gt;data) &#123; struct Link *p = (struct Link*)malloc(sizeof(struct Link)); p-&gt;data = la-&gt;data; p-&gt;next = NULL; rc-&gt;next = p; rc = p; la = la-&gt;next; lb = lb-&gt;next; &#125; else &#123; la-&gt;data &lt; lb-&gt;data ? la = la-&gt;next : lb = lb-&gt;next; &#125; &#125; rc-&gt;next = NULL;&#125;int main() &#123; struct Link *a, *b; Link *createLink(); void printfNowLink(Link *); a = createLink(); b = createLink(); struct Link *c = (struct Link*)malloc(sizeof(struct Link)); c-&gt;next = NULL; //linkCommon(a,b,c); listCommon(a,b,c); printfNowLink(c); return 0;&#125; 这里采用了两个方法，方法二效率更加 你所经历的苦难终将成为你一生的财富！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"交叉链表实现","slug":"数据结构百题狂练/链表/交叉链表☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/交叉链表☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E4%BA%A4%E5%8F%89%E9%93%BE%E8%A1%A8%E2%98%86/","excerpt":"","text":"题目： 设线性表 L=（a1,a2,a3,…,an-2,an-1,an）, 采用带头结点的单链表保存，设计一个空间复杂度为 O(1) 的 算法，得到 L’=（a1,an,a2,an-1,a3,an-2…） 分析： 这道题还是有一点复杂的，不过我们慢慢分析它。我们可以这样来操作，我们设置两个指针 slow 和 fast，其中 fast 每次走两步， slow 每次走一步，当 fast 到达链尾时，slow 刚好处于链表中间节点，之前我们学过链表逆置，接下来我们把 slow 后面的节点逆置， 链表就变成了（a1,a2,a3,…,an,an-1,an-2,…）, 然后我们从中间开始遍历，依次将节点插入到前面节点后面，即可完成要求。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct Link &#123; union &#123; int data; &#125;type; struct Link *next;&#125;;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void crossTheLink(Link *h) &#123; void reverse(Link *); struct Link *fast = h-&gt;next, *slow = h-&gt;next,*mid; mid = (struct Link*)malloc(sizeof(struct Link)); while (fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) &#123;//寻找中间节点 fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; mid-&gt;next = slow-&gt;next; reverse(mid);//逆转mid后面的节点 slow-&gt;next = mid-&gt;next; fast = h-&gt;next; slow-&gt;next = NULL; slow = mid-&gt;next; while (slow) &#123;//逐个进行插入 mid = slow-&gt;next; slow-&gt;next = fast-&gt;next; fast-&gt;next = slow; slow = mid; fast = fast-&gt;next-&gt;next;//因为将slow插入了，所以之前的fast下一个是现在的下两个 &#125;&#125;void reverse(Link *h) &#123; struct Link *p = h-&gt;next,*r; h-&gt;next = NULL; while (p) &#123; r = p-&gt;next; p-&gt;next = h-&gt;next; h-&gt;next = p; p = r; &#125;&#125;int main() &#123; struct Link *head,*p; Link *createLink(int); head = createLink(0); crossTheLink(head); printf(&quot;交叉后的链表为：&quot;); p = head-&gt;next; while (p) &#123; printf(&quot;%d &quot;, p-&gt;type.data); p = p-&gt;next; &#125; return 0;&#125; 遇到困难时不要抱怨，既然改变不了过去，那么就努力改变未来。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"删除链表中最小值结点","slug":"数据结构百题狂练/链表/删除链表最小值","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/删除链表最小值/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"题目：删除链表中唯一的最小值 分析： 目前能想到的就是遍历整个链表，记录下最小节点的指针，然后进行删除，时间复杂度为 O(n). 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Link &#123; int data; struct Link* next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void deleteMin(Link *p) &#123; struct Link *preMinp = p, *minP = p-&gt;next,*preQ=p-&gt;next, *q = p-&gt;next-&gt;next,*f; while (q) &#123; if (q-&gt;data &lt; minP-&gt;data) &#123;//如果比当前值更小 minP = q;//更换 preMinp = preQ;//前驱一起更换 &#125; preQ = q;//继续前进 q = q-&gt;next; &#125; f = minP; preMinp-&gt;next = minP-&gt;next;//删除 free(f);//释放 &#125;int main() &#123; int n,data; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;,&amp;n); struct Link *q; struct Link *head =(struct Link*) malloc(sizeof(struct Link)); head-&gt;next = NULL; q = head; for (int i = 0; i &lt; n;i++) &#123; struct Link *newP = (struct Link*) malloc(sizeof(struct Link)); printf(&quot;请输入第一个节点的值：&quot;); scanf(&quot;%d&quot;,&amp;data); newP-&gt;data = data; newP-&gt;next = NULL; head-&gt;next = newP; head = head-&gt;next;//head要始终指向最新节点 &#125; head-&gt;next = NULL; head = q;//最后head要指向头结点 printf(&quot;打印链表：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; head = q; deleteMin(head); printf(&quot;删除后链表值为：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; return 0;&#125; 越是无能的人，越喜欢挑剔别人的错儿。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"判断子串","slug":"数据结构百题狂练/链表/判断子串","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/判断子串/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目：存在两个单链表序列 A、B，设计函数判断 B 是否为 A 的子序列。 分析： 最直接的方法：循环遍历，从 A 链的第一个元素开始与 B 链对比，如遇见不同，从 A 链下一个又开始，直至到达链尾。还有可以使用 KMP 快速匹配，这里暂不做讲解。 代码： 1234567891011121314151617181920212223242526272829303132struct Link &#123; int data; struct Link *next; &#125;; #include &lt;stdio.h&gt; void subList(Link *a,Link *b) &#123; struct Link *la = a ,*pA = la-&gt;next, *pB = b-&gt;next; while (pA&amp;&amp;pB) &#123; if (pA-&gt;data==pB-&gt;data) &#123;//相等继续对比下一个 pA = pA-&gt;next; pB = pB-&gt;next; &#125; else &#123; pB = b-&gt;next;//pb从头开始与pa对比 la = la-&gt;next;//失败一次，la往后移动一个节点 pA = la-&gt;next;//pa从下一个节点又开始 &#125; &#125; pB == NULL ? printf(&quot;true&quot;) : printf(&quot;false&quot;);//如果pb为NULL，说明已比对完成&#125;int main() &#123; struct Link *a, *b; Link *createLink(); a = createLink(); b = createLink(); subList(a,b); return 0;&#125; 用最少的悔恨应对过去；用最少的浪费应对此刻；用最多的梦想应对未来！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"判断循环双链表是否对称","slug":"数据结构百题狂练/链表/判断循环双链表是否对称","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/判断循环双链表是否对称/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0/","excerpt":"","text":"题目：设计一个算法判断带头结点的循环双链表是否对称 分析： 简单分析，我们可以设置两个指针，pre 和 next，从头结点出发，进行比较，若 pre 与 next 所指值不同，则不对称，若 pre 和 next 指向了同一个节点 则该循环双链表对称。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Link &#123; int data; struct Link *next; struct Link *pre;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void isSymmetry(Link *h) &#123; struct Link *pre = h-&gt;pre,*next=h-&gt;next; while (pre!=next&amp;&amp;pre-&gt;pre!=next) &#123;//此时存在两种情况，奇数个节点和偶数个节点都要考虑 if (pre-&gt;data!=next-&gt;data) &#123; printf(&quot;该循环双链表不对称&quot;); break; &#125; else &#123; pre = pre-&gt;pre; next = next-&gt;next; &#125; &#125; if (pre==next||pre-&gt;pre==next) &#123; printf(&quot;该循环双链表对称&quot;); &#125;&#125;int main() &#123; int n,data; struct Link *head = (struct Link *)malloc(sizeof(struct Link)); head-&gt;next = NULL; head-&gt;pre = NULL; struct Link *p = head; printf(&quot;请输入节点个数：n=&quot;); scanf(&quot;%d&quot;,&amp;n); for (int i = 0; i &lt; n;i++) &#123; printf(&quot;请输入第%d个节点值:&quot;,i+1); scanf(&quot;%d&quot;,&amp;data); struct Link *newP = (struct Link*)malloc(sizeof(struct Link)); newP-&gt;data = data; newP-&gt;pre = p; p-&gt;next = newP; p = newP; &#125; p-&gt;next = head; head-&gt;pre = p; isSymmetry(head); return 0;&#125; 人要有足够的压力，才能超越颠峰。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"判断链表是否中心对称","slug":"数据结构百题狂练/链表/判断链表是否是中心对称","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/判断链表是否是中心对称/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%AD%E5%BF%83%E5%AF%B9%E7%A7%B0/","excerpt":"","text":"题目：设单链表的表头指针为 h，节点结构由 data 和 next 两个域构成，其中 data 域为字符型。试设计算法判断该链表的全部 n 个字符是否是中心对称，例如 xyx，xyyx 都是中心对称。 分析： 我们可以利用栈的先进后出的特性来搞定这道题，我们设置两个快慢指针，fast 和 slow，之前我们就用过这种方法，用以找到中间节点，之后将 slow 节点之后的节点依次入栈， fast 指针重新指向首节点，然后 fast 和栈内元素一一比较，若存在不同，则不对称。 关于栈相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define TYPE char struct Stack&#123; TYPE* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;; /* --------------以下为实现函数--------------------*///创建一个栈Stack *createStack(int size) &#123; struct Stack *stack = (struct Stack*)malloc(sizeof(struct Stack));//给栈分配空间 stack-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*size);//给内存首地址分配空间，大小用户指定 stack-&gt;len = size;//栈容量 stack-&gt;top = -1;//栈顶下标，当前无元素，故为-1 return stack;&#125;//判断栈满bool full(Stack *stack) &#123; return stack-&gt;top + 1 &gt;= stack-&gt;len;&#125;//判断栈空bool empty(Stack *stack) &#123; return stack-&gt;top == -1;&#125;//入栈bool push(Stack *stack,TYPE data) &#123; if (full(stack)) return false; *(stack-&gt;arr + ++stack-&gt;top) = data; return true;&#125;//出栈bool pop(Stack *stack) &#123; if (empty(stack)) return false; stack-&gt;top--; return true; &#125;//查看栈顶元素TYPE *top(Stack *stack) &#123; if (empty(stack)) return NULL; return stack-&gt;arr + stack-&gt;top;&#125; //销毁void destory(Stack *stack) &#123; free(stack-&gt;arr); free(stack); &#125; 本题实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Link &#123; union &#123; char letter; &#125;type; struct Link *next;&#125;;struct Stack &#123; int *arr; int len; int top;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;void isSymmetry(Link *h) &#123; int size; struct Stack *s; Stack *createStack(int); bool push(Stack *,char); bool empty(Stack *); char *top(Stack *); bool pop(Stack *); void destory(Stack *); printf(&quot;请输入要创建的栈的大小：size=&quot;); scanf(&quot;%d&quot;,&amp;size); s = createStack(size); struct Link *fast = h-&gt;next, *slow = h-&gt;next; while (fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = h-&gt;next; while (slow-&gt;next) &#123;//将中间元素的后面节点依次入栈 push(s,slow-&gt;next-&gt;type.letter); slow = slow-&gt;next;//我总是忘记往下走 &#125; while (!empty(s)) &#123; if (fast-&gt;type.letter != *top(s) ) &#123; printf(&quot;该链表非中心对称&quot;); break; &#125; fast = fast-&gt;next; pop(s); &#125; if(empty(s))printf(&quot;该链表是中心对称的&quot;); destory(s);//最后销毁栈&#125;int main() &#123; struct Link *head; Link *createLink(int); head = createLink(1); isSymmetry(head); return 0;&#125; 做人可以没天赋，但不能没斗志！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"判断链表是否有环,找出入环点","slug":"数据结构百题狂练/链表/判断链表是否有环，并找出入环点☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/判断链表是否有环，并找出入环点☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E5%B9%B6%E6%89%BE%E5%87%BA%E5%85%A5%E7%8E%AF%E7%82%B9%E2%98%86/","excerpt":"","text":"题目：设计一个算法判断一个链表是否有环，并找出入环点 分析：我们可以想象一下，在一个有环的赛道上，有两个人跑步，一个人跑得快，一个人跑得慢，试想，时间充足的情况下，跑得快 的那个人是不是会再次遇到跑的慢的人呢？所以对于这道题，我们也可以通过快慢指针来处理，p 指针一次移动两个节点，q 指针一次移动 一个节点，如果他们再次相遇了，说明链表有环，如果 p 指针为 NULL 了，说明无环。同时我们需要记录 p、q 各走的步数，用以确定 环的入口点。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Link &#123; union &#123; int data; &#125;type; struct Link *next;&#125;;#include &lt;stdio.h&gt;Link *isLoop(Link *h,int count) &#123; int numP = 0, numQ = 0,numS=0; struct Link *p = h-&gt;next, *q = h-&gt;next,*s=h-&gt;next; while (q-&gt;next&amp;&amp;q-&gt;next-&gt;next) &#123; p = p-&gt;next; numP++; q = q-&gt;next-&gt;next; numQ++; if (p==q) &#123;//再次相遇，说明有环 numS = count - (numQ - numP); while (numS--) &#123; s = s-&gt;next; &#125; return s; &#125; &#125; return NULL;&#125;int main() &#123; struct Link *head,*l,*s; int count = 0; Link *createLink(int); head = createLink(0); l = head-&gt;next; while (l-&gt;next) &#123;//统计链表长度 count++; l = l-&gt;next; &#125; count++;//上面的统计会少一个，所以再加一 l-&gt;next = head-&gt;next-&gt;next-&gt;next;//手动设置一个环 s=isLoop(head,count); if (s) &#123; printf(&quot;链表环起始节点值为：%d&quot;,s-&gt;type.data); &#125; else &#123; printf(&quot;该链表五环&quot;); &#125; return 0;&#125; 未遭拒绝的成功决不会长久。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表删除指定范围内的元素","slug":"数据结构百题狂练/链表/单链表删除指定范围内的元素","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/单链表删除指定范围内的元素/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：设一个带头结点的单链表所有元素的数据值无序，试编写函数删除表中介于给定的两个值（作为函数参数给出）之间的元素。 分析： 分别设置 pre，p，r 指针，遍历，符合条件便进行删除。 代码： 12345678910111213141516171819202122232425262728293031323334353637struct Link &#123; int data; struct Link *next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void deleteNum(Link *h,int min,int max) &#123; struct Link *pre = h, *p = h-&gt;next, *r; while (p) &#123; if (p-&gt;data&gt;min&amp;&amp;p-&gt;data&lt;max) &#123;//符合条件，进行删除 r = p-&gt;next; pre-&gt;next = p-&gt;next; free(p); p = r; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125;&#125;int main() &#123; int min, max; struct Link*head; Link *createLink();//创建链表的代码我单独封装了一个文件 void printfNowLink(Link*); head = createLink(); printf(&quot;请输入要删除的值所在的范围：\\n&quot;); printf(&quot;min=&quot;); scanf(&quot;%d&quot;,&amp;min); printf(&quot;max=&quot;); scanf(&quot;%d&quot;, &amp;max); deleteNum(head,min,max); printfNowLink(head); return 0;&#125; 创建链表的代码： 1234567891011121314151617181920212223242526272829303132333435struct Link &#123; int data; struct Link *next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;Link* createLink() &#123; int n, data; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;, &amp;n); struct Link *q; struct Link *head = (struct Link*) malloc(sizeof(struct Link)); head-&gt;next = NULL; q = head; for (int i = 0; i &lt; n; i++) &#123; struct Link *newP = (struct Link*) malloc(sizeof(struct Link)); printf(&quot;请输入第一个节点的值：&quot;); scanf(&quot;%d&quot;, &amp;data); newP-&gt;data = data; newP-&gt;next = NULL; head-&gt;next = newP; head = head-&gt;next;//head要始终指向最新节点 &#125; head-&gt;next = NULL; head = q;//最后head要指向头结点 printf(&quot;打印链表：&quot;); printf(&quot;\\n&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; head = q; return head;&#125; 成功永远属于那些爱拼搏的人！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表删除","slug":"数据结构百题狂练/链表/单链表删除","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/单链表删除/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4/","excerpt":"","text":"题目：设计一个递归算法，删除一个不带头结点的单链表中所有值为 x 的节点 分析： 首先我们要创建单链表，并赋值，然后递归去判断值，进行删除 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Delete&#123; int value; struct Delete *next;&#125;;void deleteX(Delete *&amp;p,int delNum) &#123;//这里的第一个函数参数必须是引用值，不然会导致断链 struct Delete *pre;//定义一个指针，进行删除 if (p == NULL) return ; if (p-&gt;value == delNum) &#123; pre = p; p = p-&gt;next; free(pre); deleteX(p,delNum); &#125; else deleteX(p-&gt;next, delNum);&#125;int main() &#123; struct Delete *p,*q,*head; int count = 0; q = (struct Delete *)malloc(sizeof(struct Delete)); head = (struct Delete *)malloc(sizeof(struct Delete)); int value,delNum; printf(&quot;请输入链表各节点的值，以-1结束：&quot;); scanf(&quot;%d&quot;, &amp;value); while (value != -1 ) &#123;//依次创建节点 p = (struct Delete *)malloc(sizeof(struct Delete)); p-&gt;value = value; p-&gt;next = NULL; if (count++==0) &#123; q = p; head = p; &#125; else &#123; q-&gt;next = p; q = p; &#125; scanf(&quot;%d&quot;,&amp;value); &#125; q-&gt;next = NULL; q = head; printf(&quot;打印链表：&quot;); while (q!=NULL) &#123; printf(&quot;%d &quot;,q-&gt;value); q = q-&gt;next; &#125; q = head; printf(&quot;请输入想要删除的节点的值：&quot;); scanf(&quot;%d&quot;,&amp;delNum); deleteX(q,delNum); printf(&quot;删除后链表：&quot;); while (q != NULL) &#123; printf(&quot;%d &quot;, q-&gt;value); q = q-&gt;next; &#125; return 0;&#125; 注：删除函数的参数必须是引用值，因为引用直接代表原始值，在递归中就不会断链 众人笑我太疯癫，我笑他人看不穿！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表就地逆置","slug":"数据结构百题狂练/链表/单链表就地逆置☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/单链表就地逆置☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B0%B1%E5%9C%B0%E9%80%86%E7%BD%AE%E2%98%86/","excerpt":"","text":"就地逆置链表 分析： 我们采用头插法或者相邻节点直接修改指向的方法来进行逆置。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct Link &#123; int data; struct Link* next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void reverse(Link *h) &#123; /* struct Link *pre = h, *p = h-&gt;next, *q = h-&gt;next,*r; //pre记录操作节点p上一个节点，q记录第一个节点，之后需要指向NULL,r用于指向每一次操作时p的后一个节点，防止断链 while (p) &#123;//遍历操作，修改指针指向 r = p-&gt;next; p-&gt;next = pre; pre = p; p = r; &#125; h-&gt;next = pre;//头指针指向最后一个节点 q-&gt;next = NULL;//第一个节点指向NULL，不然就是循环单链表了 */ //我们也可以采用头插法进行逆置,两个方法的时间复杂度均为O(N) struct Link *l = h, *p = h-&gt;next,*r; l-&gt;next = NULL; while (p) &#123; r = p-&gt;next; p-&gt;next = l-&gt;next; l-&gt;next = p; p = r; &#125; h = l;&#125;int main() &#123; int n, data; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;, &amp;n); struct Link *q; struct Link *head = (struct Link*) malloc(sizeof(struct Link)); head-&gt;next = NULL; q = head; for (int i = 0; i &lt; n; i++) &#123; struct Link *newP = (struct Link*) malloc(sizeof(struct Link)); printf(&quot;请输入第一个节点的值：&quot;); scanf(&quot;%d&quot;, &amp;data); newP-&gt;data = data; newP-&gt;next = NULL; head-&gt;next = newP; head = head-&gt;next;//head要始终指向最新节点 &#125; head-&gt;next = NULL; head = q;//最后head要指向头结点 printf(&quot;打印链表：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; head = q; reverse(head); printf(&quot;逆置后链表值为：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; return 0;&#125; 有任何不明白的地方，欢迎留言询问。 仰天大笑出门去，我辈岂是蓬蒿人！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表排序","slug":"数据结构百题狂练/链表/单链表排序☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/单链表排序☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E2%98%86/","excerpt":"","text":"有一个带头结点的单链表 L，设计一个算法使其递增有序 分析： 我们可以采用冒泡排序对其操作，使其递增有序, 时间复杂度为 O(n^2)。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct Link &#123; int data; struct Link *next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void bubbleSort(Link *h) &#123;//冒泡排序 int flag = 0;//排序标志，产生过变动就置为1 int count = 0;//记录链表长度 struct Link *pre=h, *p = h-&gt;next,*r; while (p) &#123; count++; p = p-&gt;next; &#125; p = h-&gt;next; for (int i = 0; i &lt; count;i++) &#123; flag = 0; while (p-&gt;next) &#123;//开始第i+1轮冒泡 if (p-&gt;data &gt; p-&gt;next-&gt;data) &#123;//前者大于后者，则需要交换 r = p-&gt;next-&gt;next;//r指向下一个节点，防止断链 pre-&gt;next = p-&gt;next; p-&gt;next-&gt;next = p; pre = p-&gt;next; p-&gt;next = r; flag = 1;//有改动，flag置为1 &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125; if (!flag) break;//若某一轮链表未作变换，则认定已经排好序，退出循环 pre = h;//重新从头开始遍历 p = h-&gt;next; &#125;&#125;int main() &#123; int n, data; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;, &amp;n); struct Link *q; struct Link *head = (struct Link*) malloc(sizeof(struct Link)); head-&gt;next = NULL; q = head; for (int i = 0; i &lt; n; i++) &#123; struct Link *newP = (struct Link*) malloc(sizeof(struct Link)); printf(&quot;请输入第一个节点的值：&quot;); scanf(&quot;%d&quot;, &amp;data); newP-&gt;data = data; newP-&gt;next = NULL; head-&gt;next = newP; head = head-&gt;next;//head要始终指向最新节点 &#125; head-&gt;next = NULL; head = q;//最后head要指向头结点 printf(&quot;打印链表：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; head = q; bubbleSort(head); printf(&quot;排序后链表值为：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; return 0;&#125; 成功的秘诀在于多努力一次，为了成功，你努力了几次？","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表求交集","slug":"数据结构百题狂练/链表/单链表求交集","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/单链表求交集/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B1%82%E4%BA%A4%E9%9B%86/","excerpt":"","text":"题目：已知两个链表 A、B 分别表示两个集合，其元素递增排列，编制函数，求 A 与 B 的交集，并存放于 A 链表中。 分析： 与上题类似，因为链表本身递增排序，我们可以设置两个指针，同时遍历 A、B 链表，同则保留，异则删除 代码： 1234567891011121314151617181920212223242526272829303132struct Link &#123; int data; struct Link *next;&#125;; #include &lt;stdio.h&gt;void listCommon(Link *a,Link *b) &#123; struct Link *pA = a-&gt;next, *pB = b-&gt;next,*r,*la=a;//用la指向a，便可直接链在a后面 la-&gt;next = NULL; while (pA&amp;&amp;pB) &#123; if (pA-&gt;data==pB-&gt;data) &#123; la-&gt;next = pA; la = pA; pA = pA-&gt;next; pB = pB-&gt;next; &#125; else &#123; pA-&gt;data &lt; pB-&gt;data ? pA = pA-&gt;next : pB = pB-&gt;next; &#125; &#125; la-&gt;next = NULL;&#125;int main() &#123; struct Link *a, *b; Link *createLink(); void printfNowLink(Link *); a = createLink(); b = createLink(); listCommon(a,b); printfNowLink(a); return 0;&#125; 所谓成功，就是在平凡中作出的不平凡的坚持！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表输出最小值并逐个删除","slug":"数据结构百题狂练/链表/单链表输出最小值并逐个删除","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/单链表输出最小值并逐个删除/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BE%93%E5%87%BA%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B9%B6%E9%80%90%E4%B8%AA%E5%88%A0%E9%99%A4/","excerpt":"","text":"题目：设有一个带头结点的单链表，其节点均为正值，设计一个算法，反复找出单链表中最小值输出并删除，直到单链表为空，最后删除头结点 分析： 按照以往的经验，我们需要遍历它，为了保证不断链，我们需要设置 pre，p，minPre，min，r 等 5 个指针。 代码如下： 1234567891011121314151617181920212223242526272829303132333435struct Link &#123; int data; struct Link *next;&#125;;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void inputAndDeleteLink(Link *h) &#123; struct Link *pre = h, *minPre = h, *p = h-&gt;next, *min = h-&gt;next, *r; while (h-&gt;next) &#123;//如果头结点后面还有值，说明未结束 while (p) &#123;//寻找最小值 if (min-&gt;data&gt;p-&gt;data) &#123; minPre = pre; min = p; &#125; pre = p; p = p-&gt;next; &#125; printf(&quot;%d &quot;,min-&gt;data); r = min-&gt;next; minPre-&gt;next = min-&gt;next;//删除当前最小值 free(min);//释放节点空间 p = h-&gt;next;//又重头开始遍历 pre = h; minPre = h; min = h-&gt;next; &#125; free(h);//最后释放头结点&#125;int main() &#123; struct Link *head; Link *createLink();//封装好的创建单链表函数 head = createLink(); inputAndDeleteLink(head); return 0;&#125; 学到很多东西的’诀窍，就是一下子不要学很多。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"合并两条循环单链表","slug":"数据结构百题狂练/链表/合并两条循环单链表","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/合并两条循环单链表/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E6%9D%A1%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目：有两个循环单链表，链表头指针分别为 h1 和 h2，编写一个函数将链表 h2 连接到 h1 之后，要求连接后的链表仍保持循环链表形式。 分析： 首先我们要找到 h1 的尾结点，找到尾结点后将尾结点的 next 指向 h2 的首节点，然后找到 h2 的尾结点，将其 next 指针指向 h1， 就大功告成了。 代码： 123456789101112131415161718192021222324252627struct Link &#123; int data; struct Link *next;&#125;;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void linkTwoLists(Link *h1,Link *h2) &#123; struct Link *p1 = h1-&gt;next, *p2 = h2-&gt;next; while (p1-&gt;next != h1) p1 = p1-&gt;next;//这里要去判断p1-&gt;next是否等于h1，进而判断出是否到达尾结点 p1-&gt;next = p2; while (p2-&gt;next != h2) p2 = p2-&gt;next; p2-&gt;next = h1; free(h2);//释放h2&#125;int main() &#123; struct Link *h1, *h2,*p; Link *createSinLoopLink(); h1 = createSinLoopLink(); h2 = createSinLoopLink(); linkTwoLists(h1,h2); p = h1-&gt;next; while (p!=h1) &#123; printf(&quot;%d &quot;,p-&gt;data); p = p-&gt;next; &#125; return 0;&#125; 创建循环单链表的代码如下： 12345678910111213141516171819202122232425#define _CRT_SECURE_NO_WARNINGS#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;struct Link &#123; int data; struct Link *next;&#125;;Link *createSinLoopLink() &#123; int n, data; struct Link *head = (struct Link *)malloc(sizeof(struct Link)); head-&gt;next = NULL; struct Link *p = head; printf(&quot;请输入节点个数：n=&quot;); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;请输入第%d个节点值:&quot;, i + 1); scanf(&quot;%d&quot;, &amp;data); struct Link *newP = (struct Link*)malloc(sizeof(struct Link)); newP-&gt;data = data; p-&gt;next = newP; p = newP; &#125; p-&gt;next = head; return head;&#125; 一个伟大的人有两颗心：一颗心流血，一颗心宽容。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"寻找两个链表公共起始位置","slug":"数据结构百题狂练/链表/寻找公共链表起始位置","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/寻找公共链表起始位置/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%AF%BB%E6%89%BE%E5%85%AC%E5%85%B1%E9%93%BE%E8%A1%A8%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"题目：存在这样一种情况，如果两个单词有相同的后缀，那我们可以将后缀作为公共部分存储，比如 being 和 loading，其中 ing 就可以作为 公共部分，现在存在两个链表，含有公共部分，设计一个高效算法找到其公共后缀其实位置。 分析： 我们可以这样想，如果我们单纯的让两条链表的指针同步移动，那么只有两条链表长度相同时才可能在公共部分的起始位置相遇， 所以我们应该让他们处于同一起跑线上，故而我们应该让较长的链表先走，具体走多少，应该是走过两条链表的长度之差。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct Link &#123; union &#123; int data; char letter; &#125;; Link *next;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;Link *findCommonSuffix(Link *h1,Link *h2) &#123; struct Link *p = h1-&gt;next, *q = h2-&gt;next; int countP =0, countQ = 0,gap; while (p) &#123;//遍历，获取链表长度 countP++; p = p-&gt;next; &#125; while (q) &#123; countQ++; q = q-&gt;next; &#125; if (countQ&gt;countP) &#123;//让p指针始终指向较长的那条链表 p = h2-&gt;next; q = h1-&gt;next; gap = countQ - countP; &#125; else &#123; p = h1-&gt;next; q = h2-&gt;next; gap = countP - countQ; &#125; while (gap--) p = p-&gt;next;//长链表指针先行移动gap位 while (q != p &amp;&amp; q != NULL) &#123;//当两指针不同或不为NULL时继续向后移动 q = q-&gt;next; p = p-&gt;next; &#125; return p;&#125;int main() &#123; struct Link *h1,*h2,*com,*p1,*p2,*start; Link *createLink(char *); char p[] = &quot;letter&quot;;//数据类型，char h1 = createLink(p); h2 = createLink(p); com = createLink(p);//公共部分 p1 = h1-&gt;next; p2 = h2-&gt;next; while (p1-&gt;next)p1 = p1-&gt;next;//到达链尾 while (p2-&gt;next)p2 = p2-&gt;next; p1-&gt;next = com-&gt;next;//链接公共部分 p2-&gt;next = com-&gt;next; p1 = h1-&gt;next; p2 = h2-&gt;next; while (p1) &#123; printf(&quot;%c&quot;,p1-&gt;letter); p1 = p1-&gt;next; &#125; printf(&quot;\\n&quot;); while (p2) &#123; printf(&quot;%c&quot;,p2-&gt;letter); p2 = p2-&gt;next; &#125; printf(&quot;\\n&quot;); start=findCommonSuffix(h1,h2); printf(&quot;%c&quot;,start-&gt;letter); return 0;&#125; 创建链表的方法做了一些修改，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Link &#123; union //这里采用了共用体，因为有时候我们要创建的数据类型不同 &#123; int data; char letter; &#125; type; struct Link *next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;Link* createLink(char *type) &#123; int n, data; char letter; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;, &amp;n); struct Link *q; struct Link *head = (struct Link*) malloc(sizeof(struct Link)); head-&gt;next = NULL; q = head; for (int i = 0; i &lt; n; i++) &#123; struct Link *newP = (struct Link*) malloc(sizeof(struct Link)); printf(&quot;请输入第%d个节点的值：&quot;,i+1); if (!strcmp(type, &quot;data&quot;)) &#123; scanf(&quot;%d&quot;, &amp;data); newP-&gt;type.data = data; &#125; else &#123; getchar(); scanf(&quot;%c&quot;, &amp;letter); newP-&gt;type.letter = letter; &#125; newP-&gt;next = NULL; head-&gt;next = newP; head = head-&gt;next;//head要始终指向最新节点 &#125; head-&gt;next = NULL; head = q;//最后head要指向头结点 printf(&quot;打印链表：&quot;); printf(&quot;\\n&quot;); while (head-&gt;next) &#123; if (!strcmp(type, &quot;data&quot;)) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;type.data); &#125; else &#123; printf(&quot;%c&quot;, head-&gt;next-&gt;type.letter); &#125; head = head-&gt;next; &#125; printf(&quot;\\n&quot;); head = q; return head;&#125; 人生，就要闯出一条路来！为了事业，为了奋斗的人生，尽管失去许多，但有失必有得！而得到的往往会比失去的更重要，它是人生的价值与意义。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"寻找链表倒数第k个结点","slug":"数据结构百题狂练/链表/寻找链表倒数第k个结点","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/寻找链表倒数第k个结点/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"题目：有一个带头结点的单链表，设计一个函数找到指定的倒数第 k 个节点，输出节点值，并返回 1，否则返回 0，前提不能改变链表，尽可能高效 分析： 我们可以先统计出总共的节点数 count，那么该节点的顺序数 num=count-k+1, 当然如果 k&gt;count, 直接返回 0，时间复杂度为 O(n) 这里还有另一种更加便捷的方法，只需对链表遍历一次，我们设立两个指针，最开始均指向首节点，然后让 q 先移动 k 个节点，之后 p q 同步移动，当 q 为 NULL 时，p 所在的位置便是倒数第 k 个节点的位置 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Link &#123; int data; struct Link *next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;int findTheReciprocalK(Link *h,int k) &#123;//这是第一种解法 struct Link *p = h-&gt;next; int count = 0,num; while (p) &#123;//统计元素个数 count++; p = p-&gt;next; &#125; p = h-&gt;next; if (k &gt; count) &#123; return 0; &#125; else &#123; num = count - k + 1; while (--num) &#123;//这里要用--num，如果用num--，会导致p为下一个元素，注意 p = p-&gt;next; &#125; printf(&quot;%d&quot;,p-&gt;data); return 1; &#125;&#125;int findTheReciprocalK2(Link *h,int k) &#123;//这是第二种解法 struct Link *p = h-&gt;next, *q = h-&gt;next; int count = k; while (count--) &#123; if (q==NULL) &#123; printf(&quot;倒数第%d个节点不存在&quot;,k); return 0; &#125; q = q-&gt;next; &#125; while (q!=NULL) &#123; p = p-&gt;next; q = q-&gt;next; &#125; printf(&quot;倒数第%d个节点值为：%d&quot;,k,p-&gt;data); return 1;&#125;int main() &#123; int k; struct Link *head; Link *createLink(); head = createLink(); printf(&quot;请输入要查倒数第几个数：k=&quot;); scanf(&quot;%d&quot;,&amp;k); //findTheReciprocalK(head,k); findTheReciprocalK2(head, k); return 0;&#125; 只有经历过地狱般的折磨，才有征服天堂的力量，只有流过血的手指，才能弹出世间的绝唱！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表删除(带头结点)","slug":"数据结构百题狂练/链表/带头结点的单链表删除","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/带头结点的单链表删除/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4/","excerpt":"","text":"题目：在带头结点的单链表 L 中, 删除所有值为 X 的节点，并释放其空间，假设值为 X 的节点不唯一 分析： 和上题相似，只是多了一个头结点。另我们可以采取直接遍历的方式进行删除，设置前驱结点，当前节点来保证不锻炼 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct Link &#123; int data; struct Link *next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void deleteX(Link *p,int delNum) &#123; /*struct Link* q;//这是递归方法 if (p == NULL) return; if (p-&gt;data==delNum) &#123; q = p; p = p-&gt;next; free(q); deleteX(p,delNum); &#125; else &#123; deleteX(p-&gt;next, delNum); &#125;*/ //不采取递归，直接遍历 struct Link *pre = p, *q = p-&gt;next,*r; while (q) &#123; if (q-&gt;data==delNum) &#123; r = q;//r指向待删除节点 q = q-&gt;next;// pre-&gt;next = q;//删除节点 free(r);//释放节点 &#125; else &#123; pre = q; q = q-&gt;next; &#125; &#125;&#125;int main() &#123; //创建节点 struct Link *head = (struct Link*)malloc(sizeof(struct Link)); struct Link *q = (struct Link*)malloc(sizeof(struct Link)); q = head; head-&gt;next = NULL; int n,data,delNum; printf(&quot;请输入节点个数：&quot;); scanf(&quot;%d&quot;,&amp;n); for (int i = 0; i &lt; n;i++) &#123; printf(&quot;请输入第%d个节点值：&quot;,i+1); struct Link *p = (struct Link*)malloc(sizeof(struct Link)); scanf(&quot;%d&quot;,&amp;data); p-&gt;data = data; head-&gt;next = p; head = p; &#125; head-&gt;next = NULL;//这里要将指针的next指向NULL，不然后面的判断会出问题，而且这也是应该养成的好习惯 head = q;//head回到头结点 printf(&quot;当前链表值为：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;,head-&gt;next-&gt;data); head = head-&gt;next; &#125; printf(&quot;\\n&quot;); printf(&quot;请输入要删除的值：&quot;); scanf(&quot;%d&quot;,&amp;delNum); head = q;//head回到头结点 deleteX(head,delNum); printf(&quot;删除后链表值为：&quot;); while (head-&gt;next) &#123; printf(&quot;%d &quot;, head-&gt;next-&gt;data); head = head-&gt;next; &#125; return 0;&#125; 世上无难事只怕有心人！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单链表逆序输出","slug":"数据结构百题狂练/链表/逆序打印单链表","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/逆序打印单链表/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目： 有一带头结点的链表，设计一算法从尾到头的输出每个节点的值。 分析： 这种类型就有点像是栈的性质，我们可以利用递归来处理，出口便是尾元素。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637struct Link &#123; int data; struct Link* next;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void reverseOutput(Link *p) &#123; if (p == NULL) return; else &#123; reverseOutput(p-&gt;next); printf(&quot;%d &quot;,p-&gt;data); &#125;&#125;int main() &#123; int n,data; printf(&quot;请输入创建链表的节点个数：&quot;); scanf(&quot;%d&quot;,&amp;n); struct Link *q; struct Link *head =(struct Link*) malloc(sizeof(struct Link)); head-&gt;next = NULL; q = head; for (int i = 0; i &lt; n;i++) &#123; struct Link *newP = (struct Link*) malloc(sizeof(struct Link)); printf(&quot;请输入第一个节点的值：&quot;); scanf(&quot;%d&quot;,&amp;data); newP-&gt;data = data; newP-&gt;next = NULL; head-&gt;next = newP; head = head-&gt;next;//head要始终指向最新节点 &#125; head-&gt;next = NULL; head = q;//最后head要指向头结点 reverseOutput(head-&gt;next); return 0;&#125; 困难像弹簧，你弱它就强！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"按照奇偶拆分链表","slug":"数据结构百题狂练/链表/按照奇偶拆分链表","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/按照奇偶拆分链表/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E6%8C%89%E7%85%A7%E5%A5%87%E5%81%B6%E6%8B%86%E5%88%86%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目：将一个带头结点单链表 A 分解成两个带头结点的单链表 A 和 B，使得 A 中含有原表中序号为奇数的元素，B 中为偶数，且保持其相对位置不变 分析： 首先我们需要分配一个节点空间为 B 作为头节点，然后设置一个 flag，为 0 时认为是奇数，链给 A，为 1 时认为是 偶数，连给 B，采用尾插法 代码如下： 12345678910111213141516171819202122232425262728293031323334353637struct Link &#123; int data; struct Link *next;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void divide(Link *lb,Link *la) &#123; int flag = 0;//做奇偶判定，因为奇数之后一定是偶数，偶数之后一定是奇数 struct Link *l=la, *p = la-&gt;next,*rb=lb,*ra=l; l-&gt;next = NULL;//原链表头结点置空 while (p) &#123;//要使其顺序不变，采用尾插法 if (!flag) &#123; ra-&gt;next = p; ra = p; flag = 1; &#125; else &#123; rb-&gt;next = p; rb = p; flag = 0; &#125; p = p-&gt;next; &#125; ra-&gt;next = NULL;//要记得将末尾节点的指针指向NULL，不然就仍然是之前的指针，导致结果不正确 rb-&gt;next = NULL;&#125;int main() &#123; struct Link *head; Link *createLink(); void printfNowLink(Link *); head = createLink(); struct Link *b = (struct Link*)malloc(sizeof(struct Link));//开辟节点空间 divide(b,head); printfNowLink(b); printfNowLink(head); return 0;&#125; 天空黑暗到必须程度，星辰就会熠熠生辉！","author":"北街学长","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"递增有序链表去重","slug":"数据结构百题狂练/链表/递增有序链表去重","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/递增有序链表去重/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/","excerpt":"","text":"题目：在一个递增有序的线性表中，有数值相同的元素存在，若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素。 分析： 对于这类去重，我们肯定需要进行遍历，而这道题给我们的是递增有序的序列，我们便可以进行一一比较，后一个元素与当前元素相同 时便删除当前元素。 代码如下： 123456789101112131415161718192021222324252627282930struct Link &#123; int data; struct Link *next;&#125;; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void deleteRep(Link *h) &#123; struct Link *pre = h, *p = h-&gt;next, *r;//删除节点必背三剑客 while (p-&gt;next) &#123; if (p-&gt;data==p-&gt;next-&gt;data) &#123;//当前节点与后续节点值相同，则删除并释放空间 r = p-&gt;next;//必须先保存后续节点，防止断链 pre-&gt;next = p-&gt;next; free(p); p = r; continue; &#125; pre = p; p = p-&gt;next; &#125;&#125;int main() &#123; struct Link * head; Link *createLink(); void printfNowLink(Link *); head = createLink(); deleteRep(head); printfNowLink(head); return 0;&#125; 既然我已经踏上这条道路，那么，任何东西都不应妨碍我沿着这条路走下去！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表去重","slug":"数据结构百题狂练/链表/链表去重☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/链表去重☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E2%98%86/","excerpt":"","text":"题目：用单链表保存 m 个整数，节点的结构为 [data][next], 且 | data|&lt;=n。现要求设计一个时间复杂度尽可能高效算法， 对于链表中绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。 分析： 题目中提到时间复杂度尽可能高效，其本上就是暗示我们采用空间换时间的方式。因为数据是小于等于 n 的，我们可以开辟一块 大小为 n 的数组，初始值为 0，之后我们遍历链表，节点值既是我们寻找的下标，如果下标所在的数组值为 0，则将值变为 1，如果 数组值已经为 1，则说明在此之前我们遇见过绝对值相同的元素，故将此节点删除。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243struct Link &#123; union &#123; int data; &#125;type; struct Link *next;&#125;;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;void deleteRepAbs(Link *h,int n) &#123; int *arr = (int *)malloc(sizeof(int)*n);//这里记住大小是sizeof(int)*n，如果只写n是不对的 for (int i = 0; i &lt; n;i++) &#123;//赋初值0 *(arr + i) = 0; &#125; struct Link *pre = h, *p = h-&gt;next, *r; while (p) &#123; if (*(arr+abs(p-&gt;type.data))==0) &#123;//首次访问，作上记录 *(arr + abs(p-&gt;type.data)) = 1; pre = p; p = p-&gt;next; &#125; else &#123; r = p-&gt;next; pre-&gt;next = p-&gt;next;//删除 free(p);//释放 p = r; &#125; &#125;&#125;int main() &#123; struct Link *head,*p; int n = 100;//我们这里默许创建的链表里的节点值的绝对值&lt;=100 Link *createLink(int); head = createLink(0);//0代表我要创建的链表值类型为int deleteRepAbs(head,n); p = head-&gt;next; printf(&quot;去重后链表为：&quot;); while (p) &#123; printf(&quot;%d &quot;,p-&gt;type.data); p = p-&gt;next; &#125; return 0;&#125; 未来总留着什么给对它抱有信心的人。","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表递增输出并释放空间","slug":"数据结构百题狂练/链表/链表递增输出并释放空间","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/链表/链表递增输出并释放空间/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E9%80%92%E5%A2%9E%E8%BE%93%E5%87%BA%E5%B9%B6%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4/","excerpt":"","text":"题目：按递增次序输出单链表各节点的数据元素，并释放节点所占的存储空间。 分析： 我们可以先进行排序，然后依次输出，并释放节点空间，我们也可以直接进行遍历，找到目前最小值进行输出，然后释放，注意不要断链 我们这里采取第二种方式，时间复杂度为 O(n)。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142struct Link &#123; int data; struct Link *next;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void printAndDel(Link *h) &#123; struct Link *pre = h, *p = h-&gt;next, *r,*min=h-&gt;next,*minPre=h;//为了操作的顺利进行，我们需要时刻保存节点的前驱与后继 int count = 0; while (p) &#123; count++; p = p-&gt;next; &#125; p = h-&gt;next; printf(&quot;输出顺序为：\\n&quot;); for (int i = 0; i &lt; count;i++) &#123; while (p) &#123; if (p-&gt;data &lt; min-&gt;data) &#123; minPre = pre; min = p; &#125; pre = p; p = p-&gt;next; &#125; printf(&quot;%d &quot;,min-&gt;data); r = min-&gt;next; minPre-&gt;next = min-&gt;next; free(min); pre = minPre = h; p = min = h-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; struct Link *head; Link *createLink(); void printfNowLink(Link*); head = createLink(); printAndDel(head); printfNowLink(head); return 0;&#125; 理论彻底，策略准确。然后以排除万难坚定不移的勇气和精神向前干去，必有成功的一日！","categories":[{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"读取文件创建二叉树","slug":"数据结构百题狂练/树/C_语言读取文件内容创建二叉树","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/C_语言读取文件内容创建二叉树/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/C_%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"文件内容格式： 解释：一行中 如 1 2 3 代表 1 有左孩子 2， 有右孩子 3 ；如 2 0 4 代表 2 没有左孩子 ，有右孩子 4 需要注意的是 ：你必须按照顺序来进行书写 也就是说 写了 1 2 3 那你必须先写 2 即便 2 没有左右孩子 也要写成 2 0 0 然后再写 3 x x，这样才符合我的代码逻辑 上面文件所创建的二叉树样式如下 创建代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061biTree* createInFile() &#123;//从文件中读取二叉树数据，注：文件数据存储为 每一行 根 左孩子 右孩子 FILE* fp; int root, lNode, rNode;//三者分别对应文档中一行中的值，即根和左右孩子 biTree* T = (biTree*)malloc(sizeof(biTree)); T-&gt;lchild = NULL; T-&gt;rchild = NULL; Squeue* createQueue(int); bool isEmpty(Squeue * ); bool enQueue(Squeue*, biTree*, int); bool isEmpty(Squeue*); bool deQueue(Squeue*, biTree**, int); biTree* p = T;//工作指针 Squeue* sq = createQueue(MAXSIZE); fp = fopen(&quot;biTree.txt&quot;, &quot;r&quot;);//打开文件 int flag = 0;//判断是否是第一次操作 while (3 == fscanf(fp, &quot;%d %d %d&quot;, &amp;root, &amp;lNode, &amp;rNode)) &#123; !flag++ ? p-&gt;data = root : deQueue(sq, &amp;p, MAXSIZE);//利用flag，进而判断是否是读取第一行，因为此时队列无数据 biTree* left = (biTree*)malloc(sizeof(biTree));//创建左孩子节点指针 biTree* right = (biTree*)malloc(sizeof(biTree));//创建右孩子节点指针 if (lNode) &#123;//如果值不为零(0代表没有孩子)，创建左孩子并赋值 left-&gt;data = lNode; p-&gt;lchild = left;//连接孩子 &#125; else &#123;//否则直接将左孩子置为空 p-&gt;lchild = NULL; &#125; if (rNode) &#123;//如果值不为零，创建右孩子孩子并赋值 right-&gt;data = rNode; p-&gt;rchild = right; &#125; else &#123;//否则直接将右孩子置为空 p-&gt;rchild = NULL; &#125; //把左右孩子入队，方便下次操作 if (p-&gt;lchild)enQueue(sq, p-&gt;lchild, MAXSIZE);//左孩子入队 if (p-&gt;rchild)enQueue(sq, p-&gt;rchild, MAXSIZE);//左孩子入队 &#125; while (!isEmpty(sq)) &#123;//将剩余节点的左右孩子置为空 deQueue(sq, &amp;p, MAXSIZE);//取出队首节点 p-&gt;lchild = NULL; p-&gt;rchild = NULL; &#125; fclose(fp); return T;&#125; //先序递归遍历void preOrder(biTree* T) &#123; if (T != NULL) &#123; printf(&quot;%d &quot;, T-&gt;data); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125;int main() &#123; biTree* T; T = createInFile(); preOrder(T); return 0;&#125; 如上，易看出用到了队列这个数据结构，所以想要运行，还需队列相关代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 此文件用于创建一个顺序队列，出队，入队,判断队空，判断队满等操作*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TYPE biTree* //#define TYPE char//#define TYPE int struct biTree &#123; char data; biTree *lchild; biTree *rchild;&#125;;struct Squeue &#123; TYPE *arr; int front, rear;&#125;;//创建队列Squeue *createQueue(int n) &#123; Squeue *sq = ( Squeue *)malloc(sizeof( Squeue)); sq-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*n);//数组大小 sq-&gt;front = 0; sq-&gt;rear = 0; return sq;&#125;//判断队满(这里采用牺牲一个存储单元来实现,约定队头指针在队尾指针的下一个位置作为队满的标志)bool isFull(Squeue *sq, int maxSize) &#123; return (sq-&gt;rear + 1) % maxSize == sq-&gt;front;&#125;//判断队空bool isEmpty(Squeue *sq) &#123; return sq-&gt;front == sq-&gt;rear;&#125;//判断队列中元素个数int count(Squeue *sq, int maxSize) &#123; return (sq-&gt;rear - sq-&gt;front + maxSize) % maxSize;&#125;//入队bool enQueue(Squeue *sq, TYPE data, int maxSize) &#123; if (isFull(sq, maxSize)) return false; sq-&gt;arr[sq-&gt;rear] = data; sq-&gt;rear = (sq-&gt;rear + 1) % maxSize; return true;&#125; //出队bool deQueue(Squeue *sq, TYPE *data,int maxSize) &#123; if (isEmpty(sq)) return false; *data = sq-&gt;arr[sq-&gt;front]; sq-&gt;front = (sq-&gt;front + 1) % maxSize; return true;&#125; //打印队列中元素//void printQ(Squeue *sq,int maxSize) &#123;// if (isEmpty(sq)) return ;// int np = sq-&gt;front;// while (np!=sq-&gt;rear) &#123;// printf(&quot;%d &quot;,sq-&gt;arr[np]);// np = (np + 1) % maxSize;// &#125;//&#125; 如你想要运行，这两个代码文件均需具备 运行结果如下：先序遍历结果","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"中序非递归遍历","slug":"数据结构百题狂练/树/中序遍历（非递归）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/中序遍历（非递归）/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89/","excerpt":"","text":"试写出中序遍历的非递归算法 分析： 如果采用非递归，我们就需要用到栈这个数据结构了，具体流程为：从根节点一路往下找左孩子并将其入栈直至左孩子为空 然后依次出栈，并判断是否存在右孩子，如果有，右孩子入栈，继续往下找左孩子，如此重复直至栈空。 本题代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct biTree &#123;//树的结构体 char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Stack &#123;//栈的结构体 char* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void inOrder(biTree *T,Stack *s) &#123;//中序遍历 biTree *p = T; bool empty(Stack *); bool pushS(Stack *,biTree * ); biTree *top(Stack *); bool pop(Stack *); while (p||!empty(s)) &#123; if (p) &#123;//一路向左 pushS(s,p); p = p-&gt;lchild; &#125; else &#123; p = top(s); printf(&quot;%c &quot;,p-&gt;data);//打印栈顶元素 pop(s);//栈顶元素出栈 p = p-&gt;rchild;//向右寻找 &#125; &#125;&#125;int main() &#123; int count=0; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack)); biTree *create(biTree*); void nodeNum(biTree *,int *); Stack *createStack(int); T = create(T); nodeNum(T,&amp;count); s = createStack(count);//创建二叉树节点个数大小的栈 inOrder(T,s); return 0;&#125; 二叉树想过代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define _CRT_SECURE_NO_WARNINGS#define TYPE charstruct biTree &#123; TYPE data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; biTree *create(biTree *T) &#123;//这里我们采用先序创建一颗二叉树 char data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%c&quot;,&amp;data); getchar(); if (data != &#x27;#&#x27;) &#123; T = (biTree *)malloc(sizeof(biTree)); T-&gt;data = data; T-&gt;lchild = NULL; T-&gt;rchild = NULL; T-&gt;lchild = create(T-&gt;lchild); T-&gt;rchild = create(T-&gt;rchild); &#125; return T;&#125;//中序递归遍历void inOrder(biTree *T) &#123; if (T!=NULL) &#123; inOrder(T-&gt;lchild); printf(&quot;%c &quot;,T-&gt;data); inOrder(T-&gt;rchild); &#125;&#125;//先序递归遍历void preOrder(biTree *T) &#123; if (T != NULL) &#123; printf(&quot;%c &quot;, T-&gt;data); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125;//后序递归遍历void postOrder(biTree *T) &#123; if (T != NULL) &#123; postOrder(T-&gt;lchild); postOrder(T-&gt;rchild); printf(&quot;%c &quot;, T-&gt;data); &#125;&#125;//统计节点个数void nodeNum(biTree *T,int *num) &#123; if (T != NULL) &#123; (*num)++;//注意这里++的优先级高于*，要加上括号 nodeNum(T-&gt;lchild,num); nodeNum(T-&gt;rchild,num); &#125;&#125; 栈相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define TYPE biTree struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;; struct Stack&#123; TYPE* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;; /* --------------以下为实现函数--------------------*///创建一个栈Stack *createStack(int size) &#123; struct Stack *stack = (struct Stack*)malloc(sizeof(struct Stack));//给栈分配空间 stack-&gt;arr = (TYPE *)malloc(sizeof(TYPE)*size);//给内存首地址分配空间，大小用户指定 stack-&gt;len = size;//栈容量 stack-&gt;top = -1;//栈顶下标，当前无元素，故为-1 return stack;&#125;//判断栈满bool full(Stack *stack) &#123; return stack-&gt;top + 1 &gt;= stack-&gt;len;&#125;//判断栈空bool empty(Stack *stack) &#123; return stack-&gt;top == -1;&#125;//入栈(具体值)bool push(Stack *stack,TYPE data) &#123; if (full(stack)) return false; *(stack-&gt;arr + ++stack-&gt;top) = data; return true;&#125;//入栈（结构体）bool pushS(Stack *stack, biTree* p) &#123; if (full(stack)) return false; (stack-&gt;arr + ++stack-&gt;top)-&gt;data = p-&gt;data; (stack-&gt;arr + stack-&gt;top)-&gt;lchild = p-&gt;lchild; (stack-&gt;arr + stack-&gt;top)-&gt;rchild = p-&gt;rchild; return true;&#125;//出栈bool pop(Stack *stack) &#123; if (empty(stack)) return false; stack-&gt;top--; return true; &#125;//查看栈顶元素TYPE *top(Stack *stack) &#123; if (empty(stack)) return NULL; return stack-&gt;arr + stack-&gt;top;&#125; //销毁void destory(Stack *stack) &#123; free(stack-&gt;arr); free(stack); &#125; 当你奋力前行，全世界都会为你让路！","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"层序遍历","slug":"数据结构百题狂练/树/二叉树层序遍历","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/二叉树层序遍历/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"试写出层次遍历的算法 分析： 正如名字所表现的那样，要一层一层的遍历，这里我们就需要用到队列这种数据结构了，具体做法是： 先将根节点入队，然后根节点出队，并依次将根节点的左孩子、右孩子入队。后续如此循环，直至队空 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Squeue &#123; biTree *arr; int front, rear;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void levelOrder(biTree *T,Squeue *sq,int maxSize) &#123; struct biTree *p = T; struct biTree *r = (struct biTree *)malloc(sizeof(struct biTree)); bool enQueueS(Squeue *, biTree *, int); bool isEmpty(Squeue *); bool deQueueS(Squeue *, biTree *,int); enQueueS(sq,p,maxSize); while (!isEmpty(sq)) &#123; deQueueS(sq,r,maxSize); printf(&quot;%c &quot;,r-&gt;data); if(r-&gt;lchild)enQueueS(sq, r-&gt;lchild, maxSize); if (r-&gt;rchild)enQueueS(sq, r-&gt;rchild, maxSize); &#125;&#125;int main() &#123; int count = 0; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); struct Squeue *sq = (struct Squeue *)malloc(sizeof(struct Squeue)); biTree *create(biTree *); void nodeNum(biTree *,int *); Squeue *createQueue(int); T = create(T);//创建一颗二叉树 nodeNum(T,&amp;count);//统计二叉树节点个数 sq = createQueue(count); levelOrder(T,sq,count); return 0;&#125; 失败不可怕，可怕的是还没开始你就临阵逃脱。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"寻找两节点的最近公共祖先","slug":"数据结构百题狂练/树/二叉链表之寻找两节点的最近公共祖先☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/二叉链表之寻找两节点的最近公共祖先☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E2%98%86/","excerpt":"","text":"题目：p、q 分别为指向该二叉树中任意两个节点的指针，试编写算法 ancestor(root,p,q,r), 找到 p、q 的最近公共祖先节点 r 分析： 上一道题其实可以给我们一些启示，就是我们可以将任意节点的祖先存起来，那这里我们也可以用两个栈，分别将 p、q 的祖先存在栈中，因为栈顶是最近的祖先节点，所以我们可以一次往下寻找相同节点，第一次找到的相同节点便是最近公共 祖先节点。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Stack &#123; biTree *arr; int len; int top;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void findAncestor(Stack *s, biTree *m, biTree *x) &#123;//这里将寻找祖先节点的方法封装起来 struct biTree *r = (struct biTree *)malloc(sizeof(struct biTree)); bool empty(Stack *); bool pushS(Stack *, biTree*); bool pop(Stack *); biTree *top(Stack *);//返回得是一个指针 while (m || !empty(s)) &#123; if (m) &#123;//一路将所有左孩子入栈 pushS(s, m); m = m-&gt;lchild; &#125; else &#123;//没有左孩子， m = top(s); if (m-&gt;rchild &amp;&amp; m != r) &#123;//将右子树的所有左孩子入栈 r = m; m = m-&gt;rchild; &#125; else &#123;//当既没有左孩子也没有右孩子时，该出栈了 pop(s);//被查找元素先出栈 if (m-&gt;data == x-&gt;data) &#123;//找到了，那么如果栈中有元素，那全都是它的祖先 break; &#125; m = NULL;//一定要将p置空，不然又会把m的左孩子入栈 &#125; &#125; &#125;&#125;void findNearestAncestor(biTree *T, biTree *p, biTree *q, biTree **r) &#123; int count = 0; struct biTree *m = T;//另起指针m，指向根节点 void nodeNum(biTree *, int *); nodeNum(T, &amp;count);//统计节点个数 struct Stack *sp, *sq; Stack *createStack(int); sp = createStack(count); sq = createStack(count); findAncestor(sp, m, p);//寻找p节点的祖先 findAncestor(sq, m, q);//寻找q节点的祖先 //经过上面的操作，栈sp和sq里面已经存好了p、q各自的祖先，接下来便是寻找最近祖先 bool contain(Stack *,biTree *); bool empty(Stack *); bool pushS(Stack *, biTree*); bool pop(Stack *); biTree *top(Stack *);//返回得是一个指针 while (!empty(sp)) &#123;//当sp不空 *r = top(sp); if (contain(sq,*r)) &#123;//判断sq中知否包含d break; &#125; pop(sp); &#125;&#125;int main() &#123; int count = 0; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)), *p, *q; struct biTree *r = (struct biTree *)malloc(sizeof(struct biTree)); biTree *create(biTree *); T = create(T); p = T-&gt;lchild-&gt;lchild-&gt;rchild;//手动指定一个节点，切记不要指成NULL了 q = T-&gt;rchild-&gt;rchild; //p = T-&gt;lchild; //q = T-&gt;rchild; findNearestAncestor(T, p, q, &amp;r);//记得这里要将r的地址传过去，才能进行改变 printf(&quot;p q最近公共结点为值为：%c&quot;,r-&gt;data); return 0;&#125; 你需要跟自己比的唯一一个人，就是以前的自己。你需要比一个人变得更好，那个人就是此刻的你。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"交换二叉树的每个结点的左右子树","slug":"数据结构百题狂练/树/交换二叉树的每个节点的左右子树","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/交换二叉树的每个节点的左右子树/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E4%BA%A4%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91/","excerpt":"","text":"题目：试编写一个算法将一颗二叉树的所有节点的左右子树进行交换。 分析： 我们仍然可以采用递归的方式进行交换。 代码如下： 123456789101112131415161718192021222324252627282930313233struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swapTree(biTree *T) &#123;//其本质就是从叶子节点开始进行交换，一路推进到根节点 struct biTree *p = T,*t; if (!p) return; if (!p-&gt;lchild&amp;&amp;!p-&gt;rchild) &#123;//如果没有左右孩子，就不需要交换了，直接返回 return; &#125; else &#123; swapTree(p-&gt;lchild);//交换左子树 swapTree(p-&gt;rchild);//交换右子树 t = p-&gt;lchild; p-&gt;lchild = p-&gt;rchild; p-&gt;rchild = t; &#125;&#125;int main() &#123; int num; struct biTree *T = (struct biTree*)malloc(sizeof(struct biTree)); biTree *create(biTree *); void inOrder(biTree *); T = create(T);//创建一颗二叉树 inOrder(T); printf(&quot;\\n&quot;); swapTree(T); inOrder(T); return 0;&#125; 舞台再大，你不上台，永远是个观众。平台再好，你不参与，永远是局外人。能力再大，你不行动，只能看别人成功！没有人会关心你付出过多少努力，撑得累不累，摔得痛不痛，他们只会看你最后站在什么位置，然后羡慕或鄙夷。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"孩子兄弟链表,递归求树高","slug":"数据结构百题狂练/树/以孩子兄弟链表为存储结构，请设计递归算法求树的高度","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/以孩子兄弟链表为存储结构，请设计递归算法求树的高度/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E4%BB%A5%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE%E8%A1%A8%E4%B8%BA%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E8%AF%B7%E8%AE%BE%E8%AE%A1%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%B1%82%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/","excerpt":"","text":"题目: 以孩子兄弟链表为存储结构，请设计递归算法求树的高度 **分析：**如果只有根节点，那么高度为 1，如果有左孩子，那么高度由左孩子的左子树和右子树决定，取其大者。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct node &#123; char data; node *fch, *nsib;&#125;Tree;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; Tree *create(Tree *T) &#123;//先序创建一颗二叉树 char data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%c&quot;, &amp;data); getchar(); if (data != &#x27;#&#x27;) &#123; T = (Tree *)malloc(sizeof(Tree)); T-&gt;data = data; T-&gt;fch = NULL; T-&gt;nsib = NULL; T-&gt;fch = create(T-&gt;fch); T-&gt;nsib = create(T-&gt;nsib); &#125; return T;&#125;int getHigh(Tree *T,int high) &#123; if (!T) &#123;//空返回当前高度，这是递归的出口 return high; &#125; else &#123; int lhigh = getHigh(T-&gt;fch,high+1);//记录左子树高度 int rhigh = getHigh(T-&gt;nsib,high);//记录右兄弟的高度，注意这里high不能再加一，因为他们是兄弟，平级 lhigh &gt; rhigh ? high = lhigh : high = rhigh;//取其大者 return high; &#125;&#125;int main() &#123; Tree *T = (Tree *)malloc(sizeof(Tree *)); T = create(T); int high = 0; high = getHigh(T,high); printf(&quot;树的高度为：%d&quot;,high); return 0;&#125; 你想要的，岁月凭什么给你，所有逆袭，都是有备而来，所有光芒，需要时间才能被看到，所有幸运，都是努力埋下的伏笔。所以，你不努力谁也给不了你想要的生活。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"创建二叉树","slug":"数据结构百题狂练/树/先序创建二叉树，中序、先序、后序遍历","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/先序创建二叉树，中序、先序、后序遍历/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%85%88%E5%BA%8F%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%B8%AD%E5%BA%8F%E3%80%81%E5%85%88%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"该文件用于创建一颗链表二叉树，测试创建二叉树，先序、中序、后序三种遍历方式 创建二叉树代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#define TYPE charstruct biTree &#123; TYPE data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; biTree *create(biTree *T) &#123;//这里我们采用先序创建一颗二叉树 char data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%c&quot;,&amp;data); getchar(); if (data != &#x27;#&#x27;) &#123; T = (biTree *)malloc(sizeof(biTree)); T-&gt;data = data; T-&gt;lchild = NULL; T-&gt;rchild = NULL; T-&gt;lchild = create(T-&gt;lchild); T-&gt;rchild = create(T-&gt;rchild); &#125; return T;&#125;//中序递归遍历void inOrder(biTree *T) &#123; if (T!=NULL) &#123; inOrder(T-&gt;lchild); printf(&quot;%c &quot;,T-&gt;data); inOrder(T-&gt;rchild); &#125;&#125;//先序递归遍历void preOrder(biTree *T) &#123; if (T != NULL) &#123; printf(&quot;%c &quot;, T-&gt;data); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125;//后序递归遍历void postOrder(biTree *T) &#123; if (T != NULL) &#123; postOrder(T-&gt;lchild); postOrder(T-&gt;rchild); printf(&quot;%c &quot;, T-&gt;data); &#125;&#125; 测试代码如下： 1234567891011121314151617181920212223struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; struct biTree *T = (struct biTree*)malloc(sizeof(struct biTree)); biTree *create(biTree*); void preOrder(biTree*); void inOrder(biTree*); void postOrder(biTree*); T=create(T); preOrder(T); printf(&quot;\\n&quot;); inOrder(T); printf(&quot;\\n&quot;); postOrder(T); return 0;&#125; 努力是为了站在万人中央成为别人的光。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"先序非递归遍历","slug":"数据结构百题狂练/树/先序遍历（非递归）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/先序遍历（非递归）/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89/","excerpt":"","text":"试写出先序遍历（非递归算法） 分析： 和中序遍历大同小异，唯一的差别在于每次先访问节点，在判断有没有左孩子，有则入栈，然后出栈，往右走。直至栈空 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct biTree &#123;//树的结构体 char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Stack &#123;//栈的结构体 char* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void inOrder(biTree *T, Stack *s) &#123;//中序遍历 biTree *p = T; bool empty(Stack *); bool pushS(Stack *, biTree *); biTree *top(Stack *); bool pop(Stack *); while (p || !empty(s)) &#123; if (p) &#123;//一路向左 printf(&quot;%c &quot;, p-&gt;data);//打印当前元素 pushS(s, p); p = p-&gt;lchild; &#125; else &#123; p = top(s); pop(s);//栈顶元素出栈 p = p-&gt;rchild;//向右寻找 &#125; &#125;&#125;int main() &#123; int count = 0; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack)); biTree *create(biTree*); void nodeNum(biTree *, int *); Stack *createStack(int); T = create(T); nodeNum(T, &amp;count); s = createStack(count);//创建二叉树节点个数大小的栈 inOrder(T, s); return 0;&#125; 我们有时从错误中学到的东西，可能比从美德中学到的还要多。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"删除以x为根的子树并释放空间","slug":"数据结构百题狂练/树/删除以x为根的子树并释放空间","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/删除以x为根的子树并释放空间/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%88%A0%E9%99%A4%E4%BB%A5x%E4%B8%BA%E6%A0%B9%E7%9A%84%E5%AD%90%E6%A0%91%E5%B9%B6%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4/","excerpt":"","text":"题目：已知二叉树以二叉链表存储，编写算法完成：对于树中每一个元素值为 x 的结点，删除以它为根的子树，并释放相应的空间 分析： 因为我们要删除以寻找到的元素为根的子树，所以我们删除时应采用递归后序遍历进行删除释放，寻找 x 采用先序遍历，也可以采用其他遍历方式。 代码：注意，我经常犯的错误便是指向空，应时刻注意判断是否有孩子结点，然后在进行操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void del(biTree *T) &#123;//释放结点函数 if (T) &#123; if (T-&gt;lchild)del(T-&gt;lchild); if (T-&gt;rchild)del(T-&gt;rchild); free(T); &#125;&#125;void delXsub(biTree *T, biTree *preT, int x) &#123;//这里设置一个父节点指针，因为free只会释放所在节点里面的内容，并不会置空 struct biTree *p = T; if (p-&gt;data == x) &#123; del(p); preT-&gt;lchild = NULL;//手动置空 preT-&gt;rchild = NULL; &#125; else &#123; if (T-&gt;lchild) delXsub(p-&gt;lchild,p, x); if (T-&gt;rchild) delXsub(p-&gt;rchild,p, x); &#125;&#125;int main() &#123; char x, count = 0; struct biTree *T = (struct biTree*)malloc(sizeof(struct biTree)); T-&gt;lchild = NULL; T-&gt;rchild = NULL; T-&gt;data = NULL; struct biTree *r; biTree *create(biTree *); void inOrder(biTree *); T = create(T);//创建一颗二叉树 printf(&quot;请输入要寻找的x值：x=&quot;); scanf(&quot;%c&quot;, &amp;x); delXsub(T,T, x); inOrder(T); return 0;&#125; 今天做的一切挣扎都是在为明天积蓄力量，所以别放弃。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"判断是否是一颗完全二叉树","slug":"数据结构百题狂练/树/判断一棵树是否是一颗完全二叉树☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/判断一棵树是否是一颗完全二叉树☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%80%E9%A2%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E2%98%86/","excerpt":"","text":"题目：一颗二叉树以二叉链表的形式存储，编写一个算法判断其是否是一个完全二叉树 分析： 我们仍然可以借助队列来完成这件事，具体做法为：我们依次将二叉树从上到下，从左到右入栈，包括空节点，如遇空节点， 若队列非空，则判断其后是否还存在节点，若有，则该树为非完全二叉树。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Squeue &#123; biTree data; int front, rear;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;bool isComplete(biTree *T,Squeue *sq,int maxSize) &#123; if (!T)return true; bool enQueueS(Squeue *, biTree *, int maxSize); bool deQueueS(Squeue *, biTree *, int maxSize); bool isEmpty(Squeue *); struct biTree *p = T; struct biTree *r = (struct biTree*)malloc(sizeof(struct biTree)); enQueueS(sq,p,maxSize);//根节点入队 while (!isEmpty(sq)) &#123; deQueueS(sq,r,maxSize);//取出队首元素 if (r-&gt;data != &#x27;#&#x27;) &#123; enQueueS(sq,r-&gt;lchild,maxSize); enQueueS(sq, r-&gt;rchild, maxSize); &#125; else &#123; while (!isEmpty(sq)) &#123;//如果已经来到了空节点，判断后续是否还有节点 deQueueS(sq, r, maxSize);//取出队首元素 if (r-&gt;data != &#x27;#&#x27;) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int count = 0; bool isCom; struct biTree *T = (struct biTree*)malloc(sizeof(struct biTree)); struct Squeue *sq; biTree *create(biTree *); void nodeNum(biTree *,int *); Squeue *createQueue(int); T = create(T);//创建一颗二叉树 nodeNum(T,&amp;count);//统计二叉树节点数量 sq = createQueue(count);//创建容量为二叉树节点个数大小的队列 isCom=isComplete(T,sq,count); isCom ? printf(&quot;该二叉树是完全二叉树&quot;) : printf(&quot;该二叉树不是完全二叉树&quot;); return 0;&#125; 入队时的代码有所改动 12345678bool enQueueS(Squeue *sq, biTree *p, int maxSize) &#123; if (isFull(sq, maxSize)) return false; (sq-&gt;arr + sq-&gt;rear)-&gt;data = p ? p-&gt;data : &#x27;#&#x27;;//空节点无法直接入队，做一下判断即可 (sq-&gt;arr + sq-&gt;rear)-&gt;lchild = p ? p-&gt;lchild:NULL; (sq-&gt;arr + sq-&gt;rear)-&gt;rchild = p ? p-&gt;rchild:NULL; sq-&gt;rear = (sq-&gt;rear + 1) % maxSize; return true;&#125; 你那么怕输，又怎么可能赢？你总是担心自己做不好，一旦技不如人就觉得世界都是灰色的。是的，你没那么好，那又怎样？谁不是在无数次的失败后，才找到通往成功的路。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"判断是否是二叉排序树","slug":"数据结构百题狂练/树/判断一颗二叉树是否是二叉排序树","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/判断一颗二叉树是否是二叉排序树/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%88%A4%E6%96%AD%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","excerpt":"","text":"题目：编写一个算法判断给定的二叉树是否是二叉排序树 分析： 二叉排序树的中序序列是升序序列，我们可以根据这一特性来进行判定 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct node &#123; int data; node *left, *right;&#125;Tree;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;Tree *create(Tree *T) &#123;//先序创建一颗二叉树 int data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%d&quot;, &amp;data); getchar(); if (data != -1) &#123; T = (Tree *)malloc(sizeof(Tree)); T-&gt;data = data; T-&gt;left = NULL; T-&gt;right = NULL; T-&gt;left = create(T-&gt;left); T-&gt;right = create(T-&gt;right); &#125; return T;&#125;bool isSortTree(Tree *T) &#123; static int min = -32768;//最开始设定min为最小值，确保第一个节点能够进行下去 static bool flag = true;//作为是否是排序的标记，采用静态变量，不然每次都会初始化 if (T) &#123; isSortTree(T-&gt;left); if (T-&gt;data &lt; min) flag = false; else min = T-&gt;data; isSortTree(T-&gt;right); &#125; return flag;&#125;int main() &#123; //先创建一颗二叉树 Tree *T = (Tree *)malloc(sizeof(Tree *)); T = create(T); isSortTree(T) ? printf(&quot;是二叉排序树&quot;) : printf(&quot;不是二叉排序树&quot;); return 0;&#125; 人的一生中不可能会一帆风顺，总会遇到一些挫折，当你对生活失去了信心的时候，仔细的看一看、好好回想一下你所遇到的最美好的事情吧，那会让你感觉到生活的美好。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"判断两棵树是否相似","slug":"数据结构百题狂练/树/判断两棵树是否相似","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/判断两棵树是否相似/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%88%A4%E6%96%AD%E4%B8%A4%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC/","excerpt":"","text":"题目：试设计判断两课二叉树是否相似的算法。所谓二叉树 T1 和 T2 相似，指的是 T1 和 T2 都是空的二叉树或只有一个根节点；或二者左子树相似 且左子树相似 分析： 典型的要采取递归来处理 代码： 12345678910111213141516171819202122232425262728293031323334353637struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;bool isSimilar(biTree *T1, biTree *T2) &#123; if (!T1 &amp;&amp; !T2) &#123;//T1,T2都是空的二叉树 return true; &#125; else if (!T1 || !T2) &#123;//T1,T2只有一个为空，则不相似 return false; &#125; else &#123; if (isSimilar(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp; isSimilar(T1-&gt;rchild, T2-&gt;rchild))//左右子树均相似，才相似 return true; else return false; &#125; &#125;int main() &#123; struct biTree *T1 = (struct biTree *)malloc(sizeof(struct biTree)); struct biTree *T2 = (struct biTree *)malloc(sizeof(struct biTree)); biTree *create(biTree *); printf(&quot;第一棵树数据：\\n&quot;); T1 = create(T1); printf(&quot;\\n&quot;); printf(&quot;第二棵树数据：\\n&quot;); T2 = create(T2); isSimilar(T1, T2) ? printf(&quot;相似&quot;) : printf(&quot;不相似&quot;); return 0;&#125; 梦想也许在今天无法实现，但重要的是，它在你心里。重要的是，你一直在努力。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"判断是否是平衡二叉树","slug":"数据结构百题狂练/树/判断是否是平衡二叉树","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/判断是否是平衡二叉树/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"利用二叉树遍历的思想编写一个判断二叉树是否是二叉平衡树的算法 分析： 我们可以采取后序遍历来完成该算法，因为后序遍历不会含有重复计算。 我们对每一个节点进行判断，如果左右子树均平衡且左右子树高度差小于等于 1，则该节点平衡 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Tree &#123; int data; Tree *left, *right;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;Tree *create(Tree *T) &#123;//先序创建一颗二叉树 int data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%d&quot;, &amp;data); getchar(); if (data != -1) &#123; T = (Tree *)malloc(sizeof(Tree)); T-&gt;data = data; T-&gt;left = NULL; T-&gt;right = NULL; T-&gt;left = create(T-&gt;left); T-&gt;right = create(T-&gt;right); &#125; return T;&#125;bool isAVL(Tree *T, int *depth) &#123; if (!T) &#123;//空节点，为平衡二叉树 *depth = 0; return true; &#125; int left = 0, right = 0; if (isAVL(T-&gt;left, &amp;left) &amp;&amp; isAVL(T-&gt;right, &amp;right)) &#123;//判断左右子树是否为平衡二叉树 int diff = left - right;//左右子树的高度差 if (abs(diff) &lt;= 1) &#123;//满足小于等于1,那就是平衡二叉树 *depth = (1 + (left &gt; right ? left : right)); return true; &#125; &#125; return false;//前面一直未返回true，那就不是平衡二叉树&#125;int main() &#123; Tree *T = (Tree *)malloc(sizeof(Tree *)); T = create(T);//创建一颗二叉树 int depth = 0; isAVL(T, &amp;depth) ? printf(&quot;是二叉平衡树&quot;):printf(&quot;不是二叉平衡树&quot;); return 0;&#125; 不要把时间、财力和劳动，浪费在空洞多余的话语上。永远以用心乐观的心态去拓展自我和身外的世界。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"后续非递归遍历","slug":"数据结构百题狂练/树/后序遍历（非递归）☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/后序遍历（非递归）☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E2%98%86/","excerpt":"","text":"试写出非递归的后序遍历算法 分析： 非递归的后续遍历较中序和先序而言，稍微复杂一点，首先我们需要一直从根节点往下寻找左孩子并入栈，之后访问栈顶元素， 并判断是否有右孩子，如果有右孩子入栈，并继续往左孩子找，直到某节点为单节点，出栈并访问。需要注意的是因为有可能一个节点我们 会访问两次，所以我们设置一个指针 r 用来表示上一次被访问过得节点，防止又把它的右孩子再次入栈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct biTree &#123;//树的结构体 char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Stack &#123;//栈的结构体 char* arr; //内存首地址 int len; //栈的容量 int top; //栈的下标&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void inOrder(biTree *T, Stack *s) &#123;//中序遍历 biTree *p = T; biTree *r = (struct biTree*)malloc(sizeof(struct biTree)); bool empty(Stack *); bool pushS(Stack *, biTree *); biTree *top(Stack *); bool pop(Stack *); while (p || !empty(s)) &#123; if (p) &#123;//一路向左 pushS(s, p); p = p-&gt;lchild; &#125; else &#123; p = top(s); if (p-&gt;rchild&amp;&amp;r!=p) &#123; r = p;//记录父节点，之后再次遇到它时，就不在将他的右孩子压入栈 p = p-&gt;rchild; &#125; else &#123; printf(&quot;%c &quot;, p-&gt;data);//打印栈顶元素 pop(s);//栈顶元素出栈 p = NULL;//这里一定要将p设为NULL，因为p的孩子已经遍历过了，不设置为NUll的话，又会将左孩子压入栈 &#125; &#125; &#125;&#125;int main() &#123; int count = 0; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack)); biTree *create(biTree*); void nodeNum(biTree *, int *); Stack *createStack(int); T = create(T); nodeNum(T, &amp;count); s = createStack(count);//创建二叉树节点个数大小的栈 inOrder(T, s); return 0;&#125; 有种脾气叫，不放弃。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"寻找先序遍历中第k个结点","slug":"数据结构百题狂练/树/寻找先序遍历中第k个结点","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/寻找先序遍历中第k个结点/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%AF%BB%E6%89%BE%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"题目：假设二叉树是用二叉链表存储，试设计一个算法, 求先序遍历中第 k（1&lt;=k&lt;= 二叉树的节点个数）个节点的值 分析： 很简单，每遍历一个节点，计数器便加一，直至等于 k 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;biTree *preK(biTree *T, int k) &#123; static int num = 0; static biTree *r; if (!T) return NULL; if (++num == k) &#123;//找到后，记录下来 r = T; &#125; else &#123; preK(T-&gt;lchild, k); preK(T-&gt;rchild, k); &#125; return r;&#125;int main() &#123; int k, count = 0; struct biTree *T = (struct biTree*)malloc(sizeof(struct biTree)); T-&gt;lchild = NULL; T-&gt;rchild = NULL; T-&gt;data = NULL; struct biTree *r; biTree *create(biTree *); void inOrder(biTree *); void nodeNum(biTree *, int *); T = create(T);//创建一颗二叉树 nodeNum(T, &amp;count); if (!count) &#123; printf(&quot;该二叉树是空树&quot;); &#125; else &#123; printf(&quot;请输入要寻找的k值（1&lt;=k&lt;=%d）：k=&quot;, count); scanf(&quot;%d&quot;, &amp;k); while (k&lt;1 || k&gt;count) &#123; printf(&quot;输入有误，请重输 k=&quot;); scanf(&quot;%d&quot;, &amp;k); &#125; r = preK(T, k); printf(&quot;第%d个节点值为%c&quot;, k, r-&gt;data); &#125; return 0;&#125; 不要以别人的标准作为自己的目标，只有你自己知道什么最适合你。不要将最贴心的人视若当然，请珍惜他们，如同对待你的生命。不要因为沉湎过去，或憧憬未来而使时间从指缝中溜走；过好今天、把握当下，你便精彩了生命的每一天。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"将叶结点连接成一个链表","slug":"数据结构百题狂练/树/将叶节点连接成一个链表☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/将叶节点连接成一个链表☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%B0%86%E5%8F%B6%E8%8A%82%E7%82%B9%E8%BF%9E%E6%8E%A5%E6%88%90%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E2%98%86/","excerpt":"","text":"题目：设计一个算法将二叉树的叶节点按从左到右的顺序连成一个单链表，表头指针为 head。二叉树按二叉链表方式存储，连接时用叶节点的 右指针来存放单链表指针。 分析： 我们要将叶节点连起来，那么我们首先要按从左至右的顺序找出叶节点，要满足这样的出场顺序，可以采用先序，中序，后序， 这里我们采用中序遍历。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Stack &#123; biTree *arr; int len; int top;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct biTree *pre = NULL;struct biTree *h = (struct biTree *)malloc(sizeof(struct biTree));//创建一个头结点biTree *leafLink(biTree *b) &#123;//将二叉树b中的所有叶子结点连起来 if (b) &#123; leafLink(b-&gt;lchild);//中序遍历左子树 if (!b-&gt;lchild &amp;&amp; !b-&gt;rchild) &#123;//叶节点 if (pre==NULL) &#123;//处理第一个节点 h = b; pre = b; &#125; else &#123; pre-&gt;rchild = b; pre = b; &#125; &#125; leafLink(b-&gt;rchild);//中序遍历右子树 pre-&gt;rchild = NULL;//设置链表尾 &#125; return h;&#125;int main() &#123; struct biTree *b = (struct biTree *)malloc(sizeof(struct biTree )); biTree *create(biTree *); b = create(b);//创建一颗二叉树 leafLink(b); while (h) &#123; printf(&quot;%c &quot;, h-&gt;data); h = h-&gt;rchild; &#125; return 0;&#125; 好运不会总是降临在你身上，你的努力是唯一能让你站住脚跟的依靠。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"已知满二叉树的先序序列求其后序序列","slug":"数据结构百题狂练/树/已知满二叉树的先序序列，求其后序序列","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/已知满二叉树的先序序列，求其后序序列/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%B7%B2%E7%9F%A5%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%EF%BC%8C%E6%B1%82%E5%85%B6%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目：设有一颗满二叉树（所有节点值均不同），已知其先序序列为 pre，设计一个算法求其后序序列 post 分析： 题目已经告诉我们是一颗满二叉树，那我们就可以从先序序列推出后序序列，因为满二叉树总是对半分的，具体操作： 1、找出先序序列的根节点，将其放入后序序列数组末尾； 2、将根节点之后的节点分成左右两堆，在分别执行上一步 3、直至全部处理完 代码如下： 123456789101112131415161718192021#include &lt;stdio.h&gt; void preToPost(char *arrPre,char *arrPost,int l1,int h1,int l2,int h2) &#123; //l1,h1,l2,h2代表arrPre和arrPost的起点和末尾 int half; if (l1 &lt;= h1) &#123; half = (h1 - l1) / 2; *(arrPost + h2) = *(arrPre + l1); preToPost(arrPre, arrPost, l1 + 1, l1 + half, l2, l2 + half - 1);//左边 preToPost(arrPre, arrPost, l1 + half + 1, h1, l2+ half, h2-1);//右边 &#125; &#125;int main() &#123; char arrPre[] = &#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;C&#x27;,&#x27;F&#x27;,&#x27;G&#x27;&#125;,arrPost[7]; preToPost(arrPre,arrPost,0,6,0,6); for (int i = 0; i &lt; 7;i++) &#123; printf(&quot;%c &quot;,*(arrPost+i)); &#125; return 0;&#125; 头等舱可以优先登机，银行 VIP 可以不用排队，演唱会最贵的门票位置是最好的，这世界从不平等，你有多努力，才有多特殊。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"将表达式树转换为中缀表达式","slug":"数据结构百题狂练/树/将表达式树转换成中缀表达式☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/将表达式树转换成中缀表达式☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E5%B0%86%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%98%86/","excerpt":"","text":"题目：请设计一个算法，将给定的表达式树，转换成等价的中缀表达式并输出。 分析： 题目已然说明我们要采取中序遍历，进而输出该表达式，那么需要注意的点便是我们的括号在哪里加，其中根节点处（也就是整个式子不需要包裹一层）和叶子结点 处（也就是操作数）不需要添加括号，其余情况在访问左子树前加左括号，访问右子树后添加右括号。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct BTree &#123; char data; struct BTree *left, *right;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; BTree *create(BTree *T) &#123;//先序简历二叉树 char data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%c&quot;, &amp;data); getchar(); if (data != &#x27;#&#x27;) &#123; T = (BTree *)malloc(sizeof(BTree)); T-&gt;data = data; T-&gt;left = NULL; T-&gt;right = NULL; T-&gt;left = create(T-&gt;left); T-&gt;right = create(T-&gt;right); &#125; return T;&#125;void putInExp(BTree *T,int deep) &#123; if (T==NULL) &#123; return; &#125; if (!T-&gt;left&amp;&amp;!T-&gt;right) &#123;//若为叶节点，直接输出操作数 printf(&quot;%c&quot;,T-&gt;data); &#125; else &#123; if (deep &gt; 1) printf(&quot;(&quot;);//非根节点，添加左括号 putInExp(T-&gt;left,deep+1); printf(&quot;%c&quot;,T-&gt;data); putInExp(T-&gt;right, deep + 1); if (deep &gt; 1) printf(&quot;)&quot;); &#125;&#125;int main() &#123; struct BTree *T = (BTree *)malloc(sizeof(BTree)); T = create(T); printf(&quot;中缀表达式为：&quot;); putInExp(T,1); return 0;&#125; 要好好努力然后多挣钱，才养得起自己这个爱吃的胃，爱玩儿的心，爱逛爱买的习惯，就算是一个人往一个人来，也能生活得很好。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"按频度排序","slug":"数据结构百题狂练/树/按频度排序☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/按频度排序☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E6%8C%89%E9%A2%91%E5%BA%A6%E6%8E%92%E5%BA%8F%E2%98%86/","excerpt":"","text":"题目：给一个非循环双向链表增加一个 freq 值，用以表示它的访问频率，每访问一次 freq 就 + 1，然后需要将该链表按照非增的顺序 排列，同时最近访问的节点排在相同频度节点的前面，以便使频繁访问的节点总是靠近表头。试编写符合上述要求的 Locate(L,x) 函数，该运算为函数过程，返回找到节点的地址，类型为指针型。 分析： 这道题咋一看很唬人，还引入了一个新概念，其实并不难，拆分开来其实就是 查找 + 排序；我们需要先找到我们要访问的节点 ，更改它的 freq 值，然后按照 freq 值的大小从表头寻找插入位置，这样便完成了一次 locate 操作。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct Link &#123; int data; struct Link *pre; struct Link *next; int freq;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void locate(Link *h,int num) &#123; int flag = 0;//找到标志 struct Link *pre=h, *p = h-&gt;next, *t,*preQ=h,*q; while (p) &#123; if (p-&gt;data==num) &#123;//如果找到 flag = 1;//表示找到 p-&gt;freq++;//freq+1 t = p;//将该节点保存起来 if (p-&gt;next) &#123; pre-&gt;next = p-&gt;next;//将该节点抠出来 p-&gt;next-&gt;pre = pre; &#125; else &#123; pre-&gt;next = NULL;//这里也要注意，如果我们查找的节点是最后一个节点，我们要将next指向NULL，不然之后遍历时会出问题 &#125; q = h-&gt;next;//这里需要注意，q应该始终指向改变了的首节点，之前我在定义时去指定，会出现bug while (q) &#123;//进行排序 if (t-&gt;freq &gt;= q-&gt;freq) &#123;//当找到的节点的freq大于等于当前遍历节点时，插入 t-&gt;next = q; q-&gt;pre = t; preQ-&gt;next = t; t-&gt;pre = preQ; break; &#125; preQ = q; q = q-&gt;next; &#125; break; &#125; pre = p; p = p-&gt;next; &#125; if (!flag) &#123; printf(&quot;未找到该元素,序列不做改变&quot;); &#125;&#125;int main() &#123; int n, data,num; struct Link *head = (struct Link *)malloc(sizeof(struct Link)); head-&gt;next = NULL; head-&gt;pre = NULL; struct Link *p = head; printf(&quot;请输入节点个数：n=&quot;); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;请输入第%d个节点值:&quot;, i + 1); scanf(&quot;%d&quot;, &amp;data); struct Link *newP = (struct Link*)malloc(sizeof(struct Link)); newP-&gt;data = data; newP-&gt;pre = p; newP-&gt;freq = 0; p-&gt;next = newP; p = newP; &#125; p-&gt;next = NULL; do &#123; printf(&quot;请输入要查找的值,输入9999代表结束：num=&quot;); scanf(&quot;%d&quot;,&amp;num); if (num == 9999)continue;//如果num=9999，跳入下一次循环 locate(head,num); p = head-&gt;next; printf(&quot;调整后链表为：\\n&quot;); while (p) &#123; printf(&quot;%d &quot;,p-&gt;data); p = p-&gt;next; &#125; &#125; while (num!=9999); return 0;&#125; 成长道路谁都会受伤，我们才刚刚起航，必须学会坚强！","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"根据中序和先序遍历创建一颗二叉树","slug":"数据结构百题狂练/树/根据中序和先序遍历创建一颗二叉树☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/根据中序和先序遍历创建一颗二叉树☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E6%A0%B9%E6%8D%AE%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%9B%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E2%98%86/","excerpt":"","text":"题目：设一个二叉树各节点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组 A、B 中，试编写算法建立该二叉树的二叉链表 分析： 这是一个典型的已知中序和先序求二叉树的案例，具体实现步骤如下： 1、先根据先序序列确定树的根节点 2、根据根节点在中序在中序序列中划分出二叉树的左右子树包含哪些节点，然后根据左右子树节点在先序序列中的次序确定子树的 的根节点，即回到步骤一。 如此重复，直到每科子树仅有一个节点为止。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;biTree *preInCreate(char *arrIn,char *arrPre,int l1,int h1,int l2,int h2) &#123; //l1 h1 为中序的第一和最后一个节点下标，l2 h2 为先序的第一和最后一个节点 int llen, rlen,i;//左子树、右子树长度 struct biTree *root = (struct biTree *)malloc(sizeof(struct biTree)); root-&gt;data = *(arrPre + l2); for (i = l1; *(arrIn + i) != root-&gt;data; i++);//找到根节点在中序序列的位置 llen = i - l1;//记录左边节点个数 rlen = h1 - i;//记录根节点右边节点个数 if (llen) &#123; root-&gt;lchild = preInCreate(arrIn,arrPre,l1,l1+llen-1,l2+1,l2+llen);//把左边的序列有看做一个新的继续找根节点 &#125; else &#123; root-&gt;lchild = NULL; &#125; if (rlen) &#123; root-&gt;rchild = preInCreate(arrIn, arrPre, h1-llen+1, h1, h2-llen+1, h2);//把右边的序列有看做一个新的继续找根节点 &#125; else &#123; root-&gt;rchild = NULL; &#125; return root;&#125;int main() &#123; char arrIn[] = &#123; &#x27;D&#x27;,&#x27;B&#x27;,&#x27;E&#x27;,&#x27;A&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;G&#x27; &#125;, arrPre[] = &#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;C&#x27;,&#x27;F&#x27;,&#x27;G&#x27;&#125;; struct biTree *root; void inOrder(biTree *); void preOrder(biTree *); root = preInCreate(arrIn,arrPre,0,6,0,6); inOrder(root); printf(&quot;\\n&quot;); preOrder(root); return 0;&#125; 世界上唯一可以不劳而获的就是贫穷，唯一可以无中生有的是梦想，没有哪件事是不动手就可以实现的。世界虽残酷，但只要你愿意走，总会有路！","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"查找节点的所有祖先结点","slug":"数据结构百题狂练/树/查找某节点的所有祖先☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/查找某节点的所有祖先☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E6%9F%A5%E6%89%BE%E6%9F%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88%E2%98%86/","excerpt":"","text":"题目：在二叉树中查找值为 x 的节点，试编写算法打印值为 x 的节点的所有祖先，假设 x 的值不多于一个。 分析： 这里我们采用后序遍历（非递归），因为在我们遇到 x 之前我们会把它的祖先节点全部入栈，当我们找到 x 时，再依次取出栈中元素 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Stack &#123; biTree *arr; int len; int top;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void findAllAncestor(biTree *T, Stack *s, char x) &#123; struct biTree *p = T; struct biTree *r = (struct biTree *)malloc(sizeof(struct biTree)); struct biTree *tp = (struct biTree *)malloc(sizeof(struct biTree)); bool pushS(Stack *, biTree*); bool pop(Stack *); biTree *top(Stack *);//返回得是一个指针 bool empty(Stack *); while (p || !empty(s)) &#123; if (p) &#123;//一路将所有左孩子入栈 pushS(s, p); p = p-&gt;lchild; &#125; else &#123;//没有左孩子， p = top(s); if (p-&gt;rchild &amp;&amp; p != r) &#123;//将右子树的所有左孩子入栈 r = p; p = p-&gt;rchild; &#125; else &#123;//当既没有左孩子也没有右孩子时，该出栈了 pop(s);//被查找元素先出栈 if (p-&gt;data == x) &#123;//找到了，那么如果栈中有元素，那全都是它的祖先 while (!empty(s)) &#123; printf(&quot;祖先元素有:&quot;); tp = top(s); printf(&quot;%c &quot;, tp-&gt;data); pop(s); &#125; &#125; p = NULL;//一定要将p置空，不然又会把p的左孩子入栈 &#125; &#125; &#125;&#125;int main() &#123; int count = 0, x; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); struct Stack *s; biTree *create(biTree *); void nodeNum(biTree *, int *); Stack *createStack(int); T = create(T); nodeNum(T, &amp;count); s = createStack(count); printf(&quot;请输入要查找的元素：x=&quot;); x = getchar(); findAllAncestor(T, s, x); return 0;&#125; 不要活在过去的阴影里，把每一天当作人生的新一天，生活才会多彩多姿。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"求二叉树的宽度","slug":"数据结构百题狂练/树/求二叉树的宽度","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/求二叉树的宽度/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6/","excerpt":"","text":"假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树的宽度（即具有节点数最多的那一层的节点个数） 分析： 这道题和求高度那道题大同小异。我们仍然可以采取层次遍历，统计每一层的节点个数，找到宽度最大的那一层。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild; &#125;;struct LinkQueue &#123;//上次求高度采用的是顺序队列，这次采用链式队列，雨露均沾哈哈 struct Link *front, *rear;&#125;; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int getWidth(biTree *b, LinkQueue *lq) &#123; int oldNum = 0, curNum = 0, width = 0;; bool enQueueN(LinkQueue *lq, biTree *node); bool deQueueN(LinkQueue *lq, biTree *node); bool isEmpty(LinkQueue *lq); struct biTree *p = b; struct biTree *r=(struct biTree*)malloc(sizeof(struct biTree)); if (p) &#123; enQueueN(lq, p);//入队 oldNum++; width = 1; while (!isEmpty(lq)) &#123; while (oldNum--) &#123; deQueueN(lq, r);//队首元素出队 if (r-&gt;lchild) &#123;//若有左孩子，将左孩子入队 enQueueN(lq, r-&gt;lchild); curNum++;//当前队列元素加1 &#125; if (r-&gt;rchild) &#123;//若有右孩子，将右孩子入队 enQueueN(lq, r-&gt;rchild); curNum++;//当前队列元素加1 &#125; &#125; curNum &gt; width ? width = curNum : NULL;//如果当前队列元素多于之前的，宽度变更 oldNum = curNum;//继续进行操作 curNum = 0; &#125; &#125; return width;&#125;int main() &#123; struct biTree *b = (struct biTree*)malloc(sizeof(struct biTree)); struct LinkQueue *lq; biTree *create(biTree *); b = create(b);//创建一颗二叉树 LinkQueue *create(); lq = create();//创建链式队列 printf(&quot;该二叉树的宽度为：%d&quot;,getWidth(b, lq)); return 0;&#125; 其中出队入队，是节点数据 12345678910111213141516171819202122/出队bool deQueue(LinkQueue *lq,TYPE *data) &#123; if (isEmpty(lq))return false; struct Link *p = lq-&gt;front-&gt;next;//保存下一个节点 *data = lq-&gt;front-&gt;next-&gt;node;//取出队首节点值 lq-&gt;front-&gt;next = p-&gt;next;//删除队首节点 if (lq-&gt;rear==p) &#123; lq-&gt;rear = lq-&gt;front; &#125; free(p); return true;&#125;//入队(一个树节点)bool enQueueN(LinkQueue *lq, TYPE *node) &#123;//队尾插入 struct Link *newd = (struct Link *)malloc(sizeof(struct Link)); newd-&gt;node.data = node-&gt;data; newd-&gt;node.lchild = node-&gt;lchild; newd-&gt;node.rchild = node-&gt;rchild; lq-&gt;rear-&gt;next = newd; lq-&gt;rear = newd; return true;&#125; 在我们的生活中，不论多难做的事情，只要你开始行动，困难总会一个一个慢慢化解。然后你会发现，不管什么目标，总会有到达的那天。当你决定出发并且为之付诸实践的时候，最困难的那部分就已经完成了。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"求指定结点在给定二叉排序树中的层次","slug":"数据结构百题狂练/树/求出给定节点在二叉排序树中的层次","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/求出给定节点在二叉排序树中的层次/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E6%B1%82%E5%87%BA%E7%BB%99%E5%AE%9A%E8%8A%82%E7%82%B9%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%AD%E7%9A%84%E5%B1%82%E6%AC%A1/","excerpt":"","text":"题目：设计一个算法，求出指定节点在给定二叉排序树中的层次 分析： 我们可以根据二叉排序树的性质，从根节点一直向下查找，每查找一次，层次便加一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct node &#123; int data; node *left, *right;&#125;Tree;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; Tree *create(Tree *T) &#123;//先序创建一颗二叉树 int data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%d&quot;, &amp;data); getchar(); if (data != -1) &#123; T = (Tree *)malloc(sizeof(Tree)); T-&gt;data = data; T-&gt;left = NULL; T-&gt;right = NULL; T-&gt;left = create(T-&gt;left); T-&gt;right = create(T-&gt;right); &#125; return T;&#125;int findLevel(Tree *T, int p) &#123; static int depth = 1; if (T) &#123; if (T-&gt;data &lt; p) &#123; findLevel(T-&gt;right, p); depth++; &#125; else if(T-&gt;data &gt; p)&#123; findLevel(T-&gt;left, p); depth++; &#125; &#125; return depth;&#125;int main() &#123; //创建一颗二叉排序树 Tree *T = (Tree *)malloc(sizeof(Tree *)); T = create(T); int p = 9,depth;//手动指定节点值 depth = findLevel(T,p); printf(&quot;该节点所在的层次为第%d层&quot;,depth); return 0;&#125; 要想赢，就一定不能怕输。不怕输，结果未必能赢。但是怕输，结果则一定是输。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"求叶结点带权路径长度之和","slug":"数据结构百题狂练/树/求叶节点带权路径长度之和","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/求叶节点带权路径长度之和/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E6%B1%82%E5%8F%B6%E8%8A%82%E7%82%B9%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目：二叉树的带权路径长度（WPL）是二叉树中所有叶节点的带权路径长度之和。给定一颗二叉树 T, 采用二叉链表存储，节点结构为 left weight right 试设计求 T 的 WPL 的算法 分析： 我们求带权路径长度，既需要知道叶节点的权值，也需要知道其经过的路径，我们可以设置一个变量 depth 代表深度，也就是 路径长度，设置一个静态变量 weight 累加带权路径，会使用到递归。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct tree &#123; int weight; struct tree *left, *right;&#125;;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;tree *create(tree *T) &#123;//建立一颗二叉树 int weight; printf(&quot;请输入当前节点权值：weight=&quot;); scanf(&quot;%d&quot;, &amp;weight); getchar(); if (weight != -1) &#123; T = (tree *)malloc(sizeof(tree)); T-&gt;weight = weight; T-&gt;left = NULL; T-&gt;right = NULL; T-&gt;left = create(T-&gt;left); T-&gt;right = create(T-&gt;right); &#125; return T;&#125;int countWPL(tree *T, int depth) &#123; static int totalWeight = 0; if (T) &#123; if (!T-&gt;left &amp;&amp; !T-&gt;right) &#123;//已经是叶节点 totalWeight += T-&gt;weight*depth;//计算带权路径 &#125; else &#123; countWPL(T-&gt;left,depth+1);//左子树 countWPL(T-&gt;right, depth + 1);//右子树 &#125; &#125; return totalWeight;&#125;int main() &#123; struct tree *T = (struct tree *)malloc(sizeof(struct tree)); T = create(T); int depth = 0; int totalW; totalW=countWPL(T, depth); printf(&quot;该二叉树的带权路径长度为：%d&quot;,totalW); return 0;&#125; 前面的路还很远，你可能会哭，但是，一定要走下去，一定不能停。输不起的人，往往就是赢不了。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"统计双分支结点个数","slug":"数据结构百题狂练/树/统计双分支节点个数","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/统计双分支节点个数/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E7%BB%9F%E8%AE%A1%E5%8F%8C%E5%88%86%E6%94%AF%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","excerpt":"","text":"题目：假设二叉树采取二叉链表存储结构存储，试设计一个算法，计算一颗给定的二叉树所有的双分支节点个数 分析： 其实二叉树各类操作都十分适合递归，这里我们同样可以采取递归的做法来进行统计双分支节点的个数。具体做法，我们 最开始便定义一个静态变量，递归出口既是无左右孩子。 代码如下： 12345678910111213141516171819202122232425262728293031struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int doubleNode(biTree *T) &#123; static int num = 0;//注意这里一定要使用静态变量，不然每一次进入递归都会初始化num if (!T)num = 0; if (T-&gt;lchild&amp;&amp;T-&gt;rchild) &#123; num++; doubleNode(T-&gt;lchild); doubleNode(T-&gt;rchild); &#125; else &#123; if (T-&gt;lchild)doubleNode(T-&gt;lchild); if (T-&gt;rchild)doubleNode(T-&gt;rchild); &#125; return num;&#125;int main() &#123; int num; struct biTree *T = (struct biTree*)malloc(sizeof(struct biTree)); biTree *create(biTree *); void nodeNum(biTree *, int *); T = create(T);//创建一颗二叉树 num = doubleNode(T); printf(&quot;该二叉树中的双分支节点个数有：%d&quot;,num); return 0;&#125; 努力，不是为了要感动谁，也不是要做给哪个人看，而是要让自己随时有能力跳出自己厌恶的圈子，并拥有选择的权利，用自己喜欢的方式过一生。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"求以孩子兄弟表示法存储的森林的叶子结点数","slug":"数据结构百题狂练/树/编程求以孩子兄弟表示法存储的森林的叶子结点数☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/编程求以孩子兄弟表示法存储的森林的叶子结点数☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E7%BC%96%E7%A8%8B%E6%B1%82%E4%BB%A5%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AD%98%E5%82%A8%E7%9A%84%E6%A3%AE%E6%9E%97%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0%E2%98%86/","excerpt":"","text":"题目：编程求以孩子兄弟表示法存储的森林的叶子结点数 分析：我们可以试想一个节点它如果有左孩子，那么根据孩子兄弟表示法的规则，那它一定不是叶节点，相反如果没有左孩子，那么 它一定是叶子结点，其右孩子即它的兄弟，同样应该这样去判断。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct node &#123; char data; node *fch, *nsib;&#125;Tree;#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; Tree *create(Tree *T) &#123;//先序创建一颗二叉树 char data; printf(&quot;请输入当前节点值：data=&quot;); scanf(&quot;%c&quot;, &amp;data); getchar(); if (data != &#x27;#&#x27;) &#123; T = (Tree *)malloc(sizeof(Tree)); T-&gt;data = data; T-&gt;fch = NULL; T-&gt;nsib = NULL; T-&gt;fch = create(T-&gt;fch); T-&gt;nsib = create(T-&gt;nsib); &#125; return T;&#125;int frostLeaf(Tree *T) &#123; if (!T) &#123;//空则返回0，也是递归的出口 return 0; &#125; else &#123; if (!T-&gt;fch) &#123;//没有左孩子，该节点为叶子结点 return 1 + frostLeaf(T-&gt;nsib); &#125; else &#123;//有左孩子，该节点不是叶子结点 return frostLeaf(T-&gt;fch) + frostLeaf(T-&gt;nsib); &#125; &#125;&#125;int main() &#123; Tree *T = (Tree *)malloc(sizeof(Tree *)); T = create(T); printf(&quot;该森林的叶子结点个数为：%d&quot;, frostLeaf(T)); return 0;&#125; 努力的意义，不是让你取得多大的成就，而是让你在平凡的日子里，活得比原来的那个自己更好一点。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"自下而上从右往左层次遍历","slug":"数据结构百题狂练/树/自下而上、从右往左层次遍历","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/自下而上、从右往左层次遍历/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E3%80%81%E4%BB%8E%E5%8F%B3%E5%BE%80%E5%B7%A6%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","excerpt":"","text":"试给出二叉树的自下而上、从右到左的层次遍历算法 分析： 我们只需要在层次遍历的基础上加入栈的使用，我们每次出队后的数据将其入栈，队列空了时，再去依次访问栈中元素，即可达到要求 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Squeue &#123; biTree *arr; int front, rear;&#125;;struct Stack &#123; biTree *arr; int len; int top;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void levelOrder2(biTree *T, Squeue *sq, int maxSize) &#123; struct Stack *s = (struct Stack *)malloc(sizeof(struct Stack)); struct biTree *p = T; struct biTree *r = (struct biTree *)malloc(sizeof(struct biTree)); bool enQueueS(Squeue *, biTree *, int); bool isEmpty(Squeue *); bool deQueueS(Squeue *, biTree *, int); Stack *createStack(int); bool pushS(Stack *,biTree *); bool empty(Stack *); biTree *top(Stack *); bool pop(Stack *); s = createStack(maxSize); enQueueS(sq, p, maxSize); while (!isEmpty(sq)) &#123; deQueueS(sq, r, maxSize); pushS(s,r); if (r-&gt;lchild)enQueueS(sq, r-&gt;lchild, maxSize); if (r-&gt;rchild)enQueueS(sq, r-&gt;rchild, maxSize); &#125; while (!empty(s)) &#123; r = top(s); printf(&quot;%c &quot;,r-&gt;data); pop(s); &#125; &#125;int main() &#123; int count = 0; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); struct Squeue *sq = (struct Squeue *)malloc(sizeof(struct Squeue)); biTree *create(biTree *); void nodeNum(biTree *, int *); Squeue *createQueue(int); T = create(T);//创建一颗二叉树 nodeNum(T, &amp;count);//统计二叉树节点个数 sq = createQueue(count); levelOrder2(T, sq, count); return 0;&#125; 付出不在于多少，只要值得就好。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"通过中序线索二叉树找某节点的后续前驱","slug":"数据结构百题狂练/树/通过中序线索二叉树找某节点的后续前驱☆","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/通过中序线索二叉树找某节点的后续前驱☆/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E6%9F%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%AD%E5%89%8D%E9%A9%B1%E2%98%86/","excerpt":"","text":"题目：写出在中序线索二叉树里查找指定节点在后序的前驱结点的算法 分析： 在后序序列中，若节点 p 有右子女，则右子女是其前驱，若无右子女而有左子女，则左子女是其前驱。若节点 p 左右子女均无， 设其中序左线索指向某祖先节点 f(p 是 f 右子树中按中序遍历的第一个节点)，若 f 有左子女，则其左子女是节点 p 在后序中的前驱； 若 f 无左子女，则顺其前驱找双亲的双亲，一直找到双亲有左子女（此时左子女是 p 的前驱）。还有一种情况，若 p 是中序遍历的第 一个节点，则节点 p 在中序和后序下均没有前驱。 要考虑到所有的情况确实不容易，先记下吧 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild; int ltag, rtag;&#125;;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;biTree *findPre(biTree *T,biTree *p) &#123;//返回前驱结点 struct biTree *f; if (p-&gt;rchild&amp;&amp;p-&gt;rtag==0) &#123;//若该节点有右孩子，那么右子女是其前驱 return p-&gt;rchild; &#125; else if(p-&gt;ltag==0&amp;&amp;p-&gt;lchild) &#123;//若该节点只有左子女则左子女是其前驱 return p-&gt;lchild; &#125; else &#123; f = p-&gt;lchild;//此时左线索指向某祖先节点 while (f&amp;&amp;f-&gt;ltag) &#123;//如果该祖先节点没有左子女，继续找前驱 f = f-&gt;lchild; &#125; if (f) &#123; return f-&gt;lchild; &#125; else &#123; return NULL; &#125; &#125;&#125;int main() &#123; struct biTree *T = (struct biTree *)malloc(sizeof(struct biTree)); biTree *create(biTree *); T = create(T); void inThread(biTree *,biTree *); inThread(T,NULL);//中序遍历建立线索 struct biTree *p = T-&gt;lchild-&gt;rchild-&gt;rchild,*pre=NULL;//手动指定一个节点 pre=findPre(T,p); if (pre) &#123; printf(&quot;节点p的前驱结点值为：%c&quot;,pre-&gt;data); &#125; else &#123; printf(&quot;节点p没有前驱结点&quot;); &#125; return 0;&#125; 我们是如何一步步落后于别人的，自己心里特别清楚，无非是从生活中一点点的差距开始的。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"非递归求二叉树高度","slug":"数据结构百题狂练/树/非递归求二叉树高度","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/非递归求二叉树高度/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E9%9D%9E%E9%80%92%E5%BD%92%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6/","excerpt":"","text":"题目：假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度 分析： 若要采用非递归的方式来求得二叉树的高度，我们采用层次遍历是最合适的，因为这一层一层的不就很好数吗哈哈。具体实现： 这里唯一的难点就在于我们如何得知高度该加一了；我们可以设置一个标志 num 用来记录每一层入栈的节点个数，当我们出栈数 达到该数值时也就意味着我们的高度该加一了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct biTree &#123; char data; struct biTree *lchild; struct biTree *rchild;&#125;;struct Squeue &#123; biTree *arr; int front, rear;&#125;; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int getHigh(biTree *T,Squeue *sq,int maxSize) &#123; int oldNum=0,curNum=0,high=0;//记录一层有多少节点 struct biTree *p = T; struct biTree *r=(struct biTree *)malloc(sizeof(struct biTree)); bool enQueueS(Squeue *, biTree *, int ); bool isEmpty(Squeue *); bool deQueueS(Squeue *, biTree *, int); enQueueS(sq,p,maxSize);//将根节点入队 oldNum++;//此时队列中只有一个节点 while (!isEmpty(sq)) &#123; deQueueS(sq,r,maxSize);//取出队首元素 if (r-&gt;lchild) &#123; curNum++;//下一层的节点数+1 enQueueS(sq, r-&gt;lchild, maxSize);//将根节点入队 &#125; if (r-&gt;rchild) &#123; curNum++;//下一层的节点数+1 enQueueS(sq, r-&gt;rchild, maxSize);//将根节点入队 &#125; if (!--oldNum) &#123;//如果一层的元素已取完，高度+1 high++; oldNum = curNum;//当oldNum=0时，将下一层的节点数赋给它 curNum = 0;//下一层节点归零 &#125; &#125; return high;&#125;int main() &#123; int count=0; //创建二叉树、队列 struct biTree *T=(struct biTree *)malloc(sizeof(struct biTree)); struct Squeue *sq; biTree *create(biTree *); void nodeNum(biTree *,int *); Squeue *createQueue(int); T = create(T); nodeNum(T,&amp;count); sq = createQueue(count);//创建一个大小为树节点个数的队列 printf(&quot;该二叉树的高度为：%d&quot;,getHigh(T, sq, count)); return 0;&#125; 努力的人生才是最好的，不要在花一样的年纪荒废了青春，真正能激励我们前行的并不是励志语录，而是身边朋友的积极上进与充满正能量的人同行！","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"顺序存储二叉树寻找公共祖先结点","slug":"数据结构百题狂练/树/顺序存储二叉树之寻找公共祖先节点","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/树/顺序存储二叉树之寻找公共祖先节点/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E6%A0%91/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%AF%BB%E6%89%BE%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目：已知一课二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为 i 和 j 的两个节点的最近的公共祖先节点的值 分析： 利用数组存储一颗二叉树，一般来说我们用这种方式存储一颗完全二叉树，不浪费空间。然后我们可以依据其下标的特性，下标的二分之一既是该节点的父节点 代码如下： 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int findCommonAncestor(int *arr,int i,int j) &#123; while (i!=j) &#123; i &gt; j ? i = i / 2: j = j / 2; &#125; return *(arr + i);&#125;int main() &#123; void createBiTree(int *,int); int count,i,j; printf(&quot;请输入所要创建的二叉树，其转换为完全二叉树的最少节点数：count=&quot;); scanf(&quot;%d&quot;,&amp;count); int *arr = (int *)malloc(sizeof(int)*(count + 2));//下标为0我们不存 createBiTree(arr,count); printf(&quot;请输入要查找公共节点的两个节点的编号,编号&lt;=%d:\\n&quot;,count); printf(&quot;i=&quot;); scanf(&quot;%d&quot;,&amp;i); printf(&quot;\\n&quot;); printf(&quot;j=&quot;); scanf(&quot;%d&quot;, &amp;j); while (i&gt;count || j&gt;count || *(arr+i)==9999||*(arr+j)==9999 )&#123; printf(&quot;编号有误，请重新输入：\\n&quot;); printf(&quot;i=&quot;); scanf(&quot;%d&quot;, &amp;i); printf(&quot;\\n&quot;); printf(&quot;j=&quot;); scanf(&quot;%d&quot;, &amp;j); &#125; count = findCommonAncestor(arr,i,j); printf(&quot;公共祖先的值为:%d&quot;,count); return 0;&#125; 创建一颗二叉树代码为： 12345678910111213#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void createBiTree(int *arr,int count) &#123; int i = 1,data; //int *arr = (int *)malloc(sizeof(int)*(count+2));//下标为0我们不存 while (count--) &#123; printf(&quot;请输入第%d个节点:&quot;,i); scanf(&quot;%d&quot;,&amp;data); *(arr + i) = data; i++; &#125;&#125; 如果心胸不似海，怎能成就海一样的事业。","categories":[{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"顺序表去重","slug":"数据结构百题狂练/顺序表/C_语言数组去重","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/C_语言数组去重/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/C_%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"题目：删除有序顺序表中重复的值，使表中所有的元素不同。 分析：因为是有序顺序表，我们可以直接进行遍历，将不同的元素存回数组 代码如下： 1234567891011121314151617181920#include &lt;stdio.h&gt;int deleteRepitition(int *arr,int len) &#123;//由于C语言无法直接修改数组长度，我们返回去重后的数组长度 int k = 0; for (int i = 0; i &lt; len;i++) &#123; if (*(arr+i)-*(arr+i+1)) &#123; *(arr + k++) = *(arr + i); &#125; &#125; if (*(arr+len-1) == *(arr+len)) &#123;//如果最后一个元素恰好和后一个存储空间元素等，则需要单独处理。 *(arr + k++) = *(arr+len-1); &#125; return k;&#125;int main() &#123; int arr[] = &#123;1,1,2,2,2,3,3,4,5&#125;; int len = sizeof(arr) / sizeof(int); len=deleteRepitition(arr,len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;,*(arr+i)); return 0;&#125; 时间复杂度 O(n)，若顺序表无序，我们可以先进行排序，在进行处理，时间复杂度 O(n^2)","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"删除顺序表中指定范围的元素","slug":"数据结构百题狂练/顺序表/删除顺序表中指定范围的元素","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/删除顺序表中指定范围的元素/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：从顺序表中删除给定区间 s~t 之间的值，若给定区间不合理或顺序表为空，则显示错误信息并退出 分析：此题与上一题大同小异，只不过，循环体内部的判定条件有了变化，我们仍然可以采用上一题的思路进行编写；即使用 k 对符合 条件的元素进行计数，一边遍历表 L 一边统计 k，当某一元素不满足条件时，就往前挪到 i-k 位置上。 代码如下： 12345678910111213141516171819202122232425262728293031#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;void deletePoint(int *arr,int s,int t,int len) &#123; int k = 0, i = 0; while (i&lt;len) &#123; if (*(arr+i)&gt;s&amp;&amp;*(arr+i)&lt;t) &#123;//满足条件 k++; &#125; else &#123; *(arr +i-k) = *(arr + i);//前移k个位置 &#125; i++; &#125; printf(&quot;当前数组为：&quot;); for (int i = 0; i &lt; len - k; i++) printf(&quot;%d &quot;,*(arr+i)); &#125;int main() &#123; int arr[] = &#123;1,4,5,6,2,7&#125;;//也可以由用户输入 int s, t;//用于给定区间范围 int len = sizeof(arr) / sizeof(int); printf(&quot;请输入区间范围,s&lt;t\\n&quot;); do &#123; printf(&quot;s=&quot;); scanf(&quot;%d&quot;,&amp;s); printf(&quot;t=&quot;); scanf(&quot;%d&quot;, &amp;t); &#125; while (s&gt;t); deletePoint(arr,s,t,len); return 0;&#125; 如果是有序顺序表的话，我们可以直接记录下大于 s 的第一个元素的位置和小于 t 的第一个元素的位置，然后后面的元素整体向前移动。","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"删除顺序表元素","slug":"数据结构百题狂练/顺序表/删除顺序表元素","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/删除顺序表元素/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目： 长度为 n，删除值为 x 的数据元素，要求时间复杂度为 O(n), 空间复杂度 O(1)。 分析： 用 k 记录删除元素个个数，一边遍历顺序表一边统计 k，并将不等于 x 的元素向前挪 k 个位置。 代码如下: 12345678910111213141516171819202122#include &lt;stdio.h&gt;void deleteX(int *arr,int n,int len) &#123; int k = 0,i=0;//进行计数 while (i&lt;len) &#123; if (*(arr+i)==n) &#123; k++; &#125; else &#123; *(arr + k) = *(arr + i); &#125; i++; &#125; for (int i = 0; i &lt; len-k; i++) &#123; printf(&quot;%d &quot;, *(arr + i)); &#125;&#125;int main() &#123; int arr[] = &#123;1,2,3,2,4,2&#125;;//也可以手动赋值的 int len = sizeof(arr) / sizeof(int); deleteX(arr,2,len);//要删除的元素也可以有用户输入 return 0;&#125; 由于 C 语言无法设置数组长度，这里只能在输出上进行控制","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"合并两个顺序表","slug":"数据结构百题狂练/顺序表/合并两个顺序表","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/合并两个顺序表/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"题目：将两个有序顺序表合并成一个新的顺序表，并由函数返回新的结果顺序表 分析：手动开辟一个数组空间，其大小要大于等于原始两个数组的长度，之后进行遍历，依次取较小值赋给新数组，若有数组未取完，剩余部分全部赋给新数组 代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int *merge(int* l1,int* l2,int len1,int len2) &#123; int* new = (int*)malloc(len1+len2);//开辟数组空间，大小为len1+len2 int k = 0,i = 0,j = 0; for (; i &lt; len1&amp;&amp;j &lt; len2;) &#123;//依次比较，较小的赋给new当前元素 if (*(l1+i)&lt;*(l2+j)) &#123; *(new + k++) = *(l1 + i++); &#125; else &#123; *(new + k++) = *(l2 + j++);//注意l1、l2不要写错了，我就是这里也写了l1导致结果不正确 &#125; &#125; while (i &lt; len1) &#123;//最后处理 *(new + k++) = *(l1 + i++); &#125; while (j &lt; len2) &#123; *(new + k++) = *(l2 + j++); &#125; return new;&#125;int main() &#123; int l1[] = &#123;1,3,5,8&#125;;//也可以手动输入 int l2[] = &#123;2,4,4,6,7&#125;; int len1 = sizeof(l1) / sizeof(int);//获取数组长度 int len2 = sizeof(l2) / sizeof(int); int *res; res = merge(l1,l2,len1,len2); for (int i = 0; i &lt; len1 + len2; i++) printf(&quot;%d &quot;,*(res+i)); return 0;&#125; 我命由我不由天！","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"循环左移","slug":"数据结构百题狂练/顺序表/循环左移","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/循环左移/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB/","excerpt":"","text":"题目：将 arr 中的存放的数据循环左移 p 个位置，即将 arr 中的 (X0,X1,…,Xn-1 变换为 (Xp，Xp-1,…,Xn-1,X0,X1,…,Xp-1))，尽可能高效 分析： 本题与逆置数组哪一题相似，我们仍然可以采取逆置数组的方式来完成题目要求，首先整体逆置，然后逆置 p 到 n-1 的数据，0 到 p-1 的数据即可完成循环左移 代码： 12345678910111213141516171819202122232425#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;void reverse(int *arr,int from,int to) &#123;//逆置函数，参数：数组，起点，终点 if (from &gt; to) &#123; return; &#125; int tmp; for (int i = from; i &lt;= (from+to)/2;i++) &#123;//i要小于等于该值的二分之一，不然中间的值没有交换 tmp = *(arr + i); *(arr + i) = *(arr + to - i +from); *(arr + to - i +from) = tmp; &#125; &#125;int main() &#123; int arr[9] = &#123;1,2,3,4,5,6,7,8,9&#125;; int p; printf(&quot;请输入左移位数p=&quot;); scanf(&quot;%d&quot;,&amp;p); reverse(arr,0,8);//整体逆置 reverse(arr,p,8);//后半段逆置 reverse(arr,0,p-1);//前半段逆置 for (int i = 0; i &lt; 9;i++)printf(&quot;%d &quot;, arr[i]); return 0;&#125; 那些打不倒你的，终将使你更强大！","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"求两等长升序序列的中位数","slug":"数据结构百题狂练/顺序表/求两等长升序序列的中位数","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/求两等长升序序列的中位数/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E6%B1%82%E4%B8%A4%E7%AD%89%E9%95%BF%E5%8D%87%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"题目：一个升序序列的中间位置的元素称为中位数，两个序列的中位数则是这两个序列升序排好序后的中间的数为中位数，现有两个等长的生序序列 A、B，找出它们的中位数。 分析： 我们可以先将这两个序列合并成一个升序序列，然后即可求出中位数，但是这样时间复杂度为 O(n)，空间复杂度也为 O(n); 我们也可以采用归并排序的想法，先求出两个序列的总元素的个数，因为他们等长，只需求出一个序列的长度，中间位置即为 len， 之后我们开始依次比较，并进行计数 count，当 count=len 时，该元素即为中位数，这样时间复杂度为 O(n), 空间复杂度为 O(1) 代码如下： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int findMidNum(int *l1,int *l2,int len) &#123; int count=0,middle; for (int i = 0, j = 0; *(l1 + i) &amp;&amp; *(l2 + j);) &#123;//依次比较，较小者出列 if (++count == len) &#123;//判断是否到达中位数的位置 middle = *(l1 + i) &lt; *(l2 + j)? *(l1 + i): *(l2 + j);//取出中位数 break; &#125; else &#123; *(l1 + i) &lt; *(l2 + j) ? i++ : j++;//没有到，继续归并 &#125; &#125; return middle;&#125;int main() &#123; int l1[] = &#123;1,3,4,7,9&#125;; int l2[] = &#123;2,4,6,8,10&#125;; int len = sizeof(l1) / sizeof(int); int middle; middle = findMidNum(l1,l2,len); printf(&quot;中位数是：%d &quot;,middle); return 0;&#125; 风萧萧兮易水寒，壮士一去兮不复还！","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"数组内部交换","slug":"数据结构百题狂练/顺序表/数组内部交换","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/数组内部交换/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E6%95%B0%E7%BB%84%E5%86%85%E9%83%A8%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"题目：已知在以为数组 A[m+n] 中依次存放两个线性表 (a1,a2…,am) 和 (b1,b2,…,bn), 现需要将两个线性表互换位置，b 在前，a 在后 分析： 要想达到这样的效果，我们可以进行三次逆置。第一次对整个数组 A 进行逆置，然后对前面的 b 进行逆置，最后对后面的 a 进行逆置，这样便达到了效果。 代码： 1234567891011121314151617181920212223#include &lt;stdio.h&gt; void reverse(int *arr,int from,int to) &#123;//逆置函数，参数：数组，起点，终点 if (from &gt; to) &#123; return; &#125; int tmp; for (int i = from; i &lt;= (from+to)/2;i++) &#123;//i要小于等于该值的二分之一，不然中间的值没有交换 tmp = *(arr + i); *(arr + i) = *(arr + to - i +from); *(arr + to - i +from) = tmp; &#125; &#125;int main() &#123; int arr[11] = &#123;1,2,3,4,5,11,22,33,44,55,66&#125;;//也可以由用户输入数组值 reverse(arr,0,10); reverse(arr, 0, 5);//因为下标从0开始，所以相应的比个数小一 reverse(arr, 6, 10); for (int i = 0; i &lt; 11; i++) printf(&quot;%d &quot;,arr[i]); return 0; &#125; 永远相信美好的事情即将发生！","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"顺序表中查找元素","slug":"数据结构百题狂练/顺序表/顺序表中查找元素","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/顺序表中查找元素/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：线性表递增有序存放，设计一算法，用最少的时间查找值为 x 的元素，若找到则将其与后续元素位置相交换，否则，插入使其仍然有序 分析： 题目告知这是一个递增有序表，要使时间最少，我们可以采取折半查找的方式，这样比顺序查找省时。 代码如下： 123456789101112131415161718192021222324252627282930313233343536#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;int findAndExchange(int* arr,int n,int len) &#123;//返回数组长度 int low = 0, high = len,middle=(low+high)/2; while (low &lt; high &amp;&amp; (middle = (low + high) / 2)) &#123; if (n == arr[middle])break; if (n&lt;arr[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; &#125; if (low &gt;= high) &#123;//未找到，插入 for (int i = len; i &gt;= middle;i--) &#123;//元素所在位置及其之后的元素后移 *(arr + i+1) = *(arr + i); &#125; *(arr + middle) = n; return len + 2; &#125; else &#123;//找到，对调 int tmp = *(arr + middle); *(arr + middle) = *(arr + middle + 1); *(arr + middle + 1) = tmp; return len+1; &#125;&#125;int main() &#123; int arr[9] = &#123;1,3,5,6,9,12,45,78&#125;; int n,len; printf(&quot;请输入你要查找的元素，n=&quot;); scanf(&quot;%d&quot;, &amp;n); len=findAndExchange(arr,n,7); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;,*(arr+i)); return 0;&#125; 山重水复疑无路，柳暗花明又一村！","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"顺序表删除最小值","slug":"数据结构百题狂练/顺序表/顺序表删除最小值","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/顺序表删除最小值/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"题目： 从顺序表中删除具有最小值的元素（假设唯一），并由函数返回被删除的值， 空出的位置有最后一个元素代替，若顺序表为空则显示错误信息并退出运行 ## 分析： 我们可以将顺序表看做数组，即我们要找出数组中最小的元素位置， 并删除它，而这里的删除之后我们会用最后一个元素替代它。综上所述，我们 可以设置一个位置标签，遍历一次找到最小的那个元素的位置，然后直接将最后一个元素的值赋予该位置 代码如下 12345678910111213141516171819202122232425262728293031#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;void deleteMin(int *arr,int len) &#123; if (!len)exit(0);//数组为空，退出运行 int minPos,min=*arr; for (int i = 1; i &lt; len;i++) &#123; if (min&gt;*(arr+i)) &#123; min = *(arr + i); minPos = i; &#125; &#125; //找到最小值之后，进行交换 *(arr + minPos) = *(arr + len - 1); *(arr + len - 1) = NULL;&#125;int main() &#123; int n;//手动输入数组长度 printf(&quot;请输入数组长度：&quot;); scanf(&quot;%d&quot;,&amp;n); int *arr = (int *)malloc(sizeof(n));//动态分配数组 printf(&quot;请输入数组的元素值，输入一个以enter结束&quot;); for (int i = 0; i &lt; n;i++) scanf(&quot;%d&quot;,arr+i); for (int i = 0; i &lt; n;i++) //原始数组 printf(&quot;%d&quot;,*(arr+i)); printf(&quot;\\n&quot;); deleteMin(arr,n); for (int i = 0; i &lt; n-1; i++)//当前数组 printf(&quot;%d&quot;, *(arr + i)); return 0;&#125; 由于会遍历整个数组，所以时间复杂度为 O(n)。我暂时想不到更好的方式降低时间复杂度，如果大家有更好的办法，欢迎留言讨论。","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"顺序表逆置","slug":"数据结构百题狂练/顺序表/顺序表逆置","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2023/12/23/数据结构百题狂练/顺序表/顺序表逆置/","permalink":"http://lhyhyl.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%99%BE%E9%A2%98%E7%8B%82%E7%BB%83/%E9%A1%BA%E5%BA%8F%E8%A1%A8/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%80%86%E7%BD%AE/","excerpt":"","text":"实现一个空间复杂度为 O(1) 的顺序表逆置算法。 分析：从第一个元素开始遍历到中间元素，使用中间变量对 a[i] 与 a[n-i+1] 进行调换，即可完成。 代码如下： 12345678910111213141516#include &lt;stdio.h&gt;void revert(int *arr,int len) &#123; int tmp; for (int i = 0; i &lt; len/2;i++) &#123;//注意这里是到len/2，不然就会又还回去，我最开始就犯了这个错误 tmp = *(arr + i); *(arr + i) = *(arr + len - i - 1); *(arr + len - i - 1) = tmp; &#125;&#125;int main() &#123; int arr[] = &#123;1,2,3,4,5,6,7&#125;;//这里的数组也可以手动赋值 int len = sizeof(arr)/4; revert(arr,len); for (int i = 0; i &lt; len;i++) printf(&quot;%d &quot;,*(arr+i)); return 0;&#125;","categories":[{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]}],"categories":[{"name":"算法经典","slug":"算法经典","permalink":"http://lhyhyl.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/categories/%E5%9B%BE/"},{"name":"讲义","slug":"讲义","permalink":"http://lhyhyl.github.io/categories/%E8%AE%B2%E4%B9%89/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/categories/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/categories/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/categories/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lhyhyl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://lhyhyl.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"红黑树","slug":"红黑树","permalink":"http://lhyhyl.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"name":"图","slug":"图","permalink":"http://lhyhyl.github.io/tags/%E5%9B%BE/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://lhyhyl.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"http://lhyhyl.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"http://lhyhyl.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"顺序表","slug":"顺序表","permalink":"http://lhyhyl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]}